<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Eric's Blog]]></title><description><![CDATA[- Game Dev - Tool Dev - Math - Machine Learning -]]></description><link>https://lxjk.github.io</link><generator>RSS for Node</generator><lastBuildDate>Sun, 01 Oct 2017 23:12:05 GMT</lastBuildDate><atom:link href="https://lxjk.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Stop Using Normal Matrix]]></title><description><![CDATA[<div class="paragraph">
<p>For rendering, I used to calculate normal matrix to transform vertex normal from model space to world space or view space. The normal matrix is defined as the inverse transpose of upper-left 3x3 matrix of the model matrix, from <a href="http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/">this article</a>. Of course matrix inverse is not a cheap operation (I discussed more about matrix inverse <a href="https://lxjk.github.io/2017/09/03/Fast-4x4-Matrix-Inverse-with-SSE-SIMD-Explained.html">here</a>), and I just realized I actually don’t need to calculate inverse transpose at all, if the model matrix is made of translation, rotation and scale, which in most of the cases your matrices will be.</p>
</div>
<div class="paragraph">
<p>Let’s revisit the problem, why we cannot just use model matrix to transform the normal? If the matrix has uniform scale, there won’t be any problem. However if the matrix has non-uniform scale, after multiplied by the matrix, our normal is no longer perpendicular to the tangent anymore.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="http://www.lighthouse3d.com/wp-content/uploads/2011/03/normalmat1.gif" alt="normalmat1.gif" width="200">
</div>
<div class="title">Figure 1</div>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="http://www.lighthouse3d.com/wp-content/uploads/2011/03/normalmat2.gif" alt="normalmat2.gif" width="200">
</div>
<div class="title">Figure 2</div>
</div>
<div class="paragraph">
<p>Now we describe the problem in math terms. Because we only transform direction, we can ignore the translation for convenience and use 3x3 matrix. The matrices used here are row major. Let our model matrix</p>
</div>
<div class="stemblock">
<div class="content">
\[M=\left( \begin{matrix} a\vec{X} \\ b\vec{Y} \\ c\vec{Z} \\ \end{matrix} \right) = \left( \begin{matrix} aX_0 &amp; aX_1 &amp; aX_2 \\ bY_0 &amp; bY_1 &amp; bY_2 \\ cZ_0 &amp; cZ_1 &amp; cZ_2 \\ \end{matrix} \right)\]
</div>
</div>
<div class="paragraph">
<p>be made of rotation (axis \(\vec{X}\), \(\vec{Y}\) and \(\vec{Z}\), where \(\vec{X}\cdot\vec{Y}=\vec{X}\cdot\vec{Z}=\vec{Y}\cdot\vec{Z}=0\), and \(\left|\vec{X}\right|=\left|\vec{Y}\right|=\left|\vec{Z}\right|=1\)), and scale \((a,b,c)\). We also have tangent \(\vec{T}=(T_0,T_1,T_2)\) and normal \(\vec{N}=(N_0,N_1,N_2)\), that \(\vec{T}\cdot\vec{N}=0\). Now after transform, tangent becomes \(\vec{T'}=\vec{T}M=a{T_0}\vec{X}+b{T_1}\vec{Y}+c{T_2}\vec{Z}\), we need to find a normal \(\vec{N'}\) such that \(\vec{T'}\cdot\vec{N'}=0\).</p>
</div>
<div class="paragraph">
<p>Remember \(\vec{X}\), \(\vec{Y}\) and \(\vec{Z}\) are unit axes perpendicular to each other, if we denote \(\vec{N'}={N'_0}\vec{X} + {N'_1}\vec{Y} + {N'_2}\vec{Z}\), we can expand this dot product.</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
\vec{T'}\cdot\vec{N'}&amp;=(a{T_0}\vec{X}+b{T_1}\vec{Y}+c{T_2}\vec{Z})\vec{N'}\\
&amp;=a{T_0}\vec{X}\cdot\vec{N'}+b{T_1}\vec{Y}\cdot\vec{N'}+c{T_2}\vec{Z}\cdot\vec{N'}\\
&amp;=a{T_0}{N'_0}+b{T_1}{N'_1}+c{T_2}{N'_2}
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Doesn’t this look familiar? We already know the original tangent and normal \(\vec{T}\cdot\vec{N}={T_0}{N_0}{T_1}{N_1}{T_2}{N_2}=0\). We can easily get our “transformed” normal</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
\vec{N'}&amp;=\frac{N_0}{a}\vec{X} + \frac{N_1}{b}\vec{Y} + \frac{N_2}{c}\vec{Z}\\
&amp;=(\frac{N_0}{a}, \frac{N_1}{b}, \frac{N_2}{c})M
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>It means instead of calculating inverse transpose of model matrix, and send a 3x3 matrix to the shader, you can simply calculate reciprocal of squared scale and send over a vector3, use that to rescale your normal and multiply by the model matrix you already have, and that’s it. Because the calculation is cheap, you can even avoid sending over extra data, and just calculate the whole thing in vertex shader (3 dot product to get squared scale from model matrix, 3 reciprocal and multiply).</p>
</div>
<div class="paragraph">
<p>Of course the normal you get need be re-normalized, but you need to do this no matter which method you use. Moreover since you have to re-normalize the normal in pixel shader anyway (because after interpolation the normal may not be of unit length), you don’t need to do anything extra in vertex shader.</p>
</div>
<div class="paragraph">
<p>Now how does the normal matrix handle the same problem? The inverse of our 3x3 model matrix is</p>
</div>
<div class="stemblock">
<div class="content">
\[M^{-1}=\left( \begin{matrix} \frac{1}{a}\vec{X} &amp; \frac{1}{b}\vec{Y} &amp; \frac{1}{c}\vec{Z} \\ \end{matrix} \right) = \left( \begin{matrix} \frac{1}{a}X_0 &amp; \frac{1}{b}Y_0 &amp; \frac{1}{c}Z_0 \\ \frac{1}{a}X_1 &amp; \frac{1}{b}Y_1 &amp; \frac{1}{c}Z_1 \\ \frac{1}{a}X_2 &amp; \frac{1}{b}Y_2 &amp; \frac{1}{c}Z_2 \\ \end{matrix} \right)\]
</div>
</div>
<div class="paragraph">
<p>It should be easy to confirm \(MM^{-1}=I\). More about matrix inverse can be found <a href="https://lxjk.github.io/2017/09/03/Fast-4x4-Matrix-Inverse-with-SSE-SIMD-Explained.html">here</a>.</p>
</div>
<div class="paragraph">
<p>The normal matrix is \(M'={(M^{-1})}^{T}=\left( \begin{matrix} \frac{1}{a}\vec{X} \\ \frac{1}{b}\vec{Y} \\ \frac{1}{c}\vec{Z} \\ \end{matrix} \right)\).</p>
</div>
<div class="paragraph">
<p>The transformed normal is \(\vec{N'}=\vec{N}M=\frac{N_0}{a}\vec{X} + \frac{N_1}{b}\vec{Y} + \frac{N_2}{c}\vec{Z}\).</p>
</div>
<div class="paragraph">
<p>Well, we got the same result.</p>
</div>
<div class="paragraph">
<p>One thing to be careful about is, this method only works if the matrix axes are perpendicular to each other, that is \(\vec{X}\cdot\vec{Y}=\vec{X}\cdot\vec{Z}=\vec{Y}\cdot\vec{Z}=0\). If your matrix is made of translation, rotation and scale, this is always true. However if you have interesting coordinate system that this does not hold, you need to fall back to using normal matrix. The proof and explanation for normal matrix in a general case can be found in <a href="http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/">this original article</a>.</p>
</div>]]></description><link>https://lxjk.github.io/2017/10/01/Stop-Using-Normal-Matrix.html</link><guid isPermaLink="true">https://lxjk.github.io/2017/10/01/Stop-Using-Normal-Matrix.html</guid><category><![CDATA[Math]]></category><category><![CDATA[Graphics]]></category><dc:creator><![CDATA[Eric Zhang]]></dc:creator><pubDate>Sun, 01 Oct 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Fast 4x4 Matrix Inverse with SSE SIMD, Explained]]></title><description><![CDATA[<div id="preamble">
<div class="sectionbody">
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel2">
<li><a href="#_transform_matrix_inverse">Transform Matrix Inverse</a></li>
<li><a href="#_general_matrix_inverse">General Matrix Inverse</a></li>
<li><a href="#_appendix">Appendix</a></li>
</ul>
</div>
<div class="paragraph">
<p>Before we start, think about this question: do we really need the inverse of a general matrix?</p>
</div>
<div class="paragraph">
<p>I came to this problem when writing a math library for my game engine. If you are making a game or 3D application, we use 4x4 matrix for object transform, which is a combination of 3D translation, rotation and scale. If most of your matrices are used as transform matrices, because of their special property, we have a fast route for calculating their inverse. In fact transform matrix inverse is only 50% of the cost compared to the optimized general matrix inverse. In the first half of this post we will talk about transform matrix.  In the second half we will dive in and explain the SIMD version of general 4x4 matrix inverse, and we compare the performance of our method with commonly used math libraries from UE4, Eigen and DirectX Math.</p>
</div>
<div class="paragraph">
<p>The matrices used in this post are row major. This is mainly for (1) easier to demonstrate and visualize with matrix data layout; (2) easier to compare with other math library. The same matrix inverse function works for both row major and column major, because \(A^{-1}=((A^{T})^{-1})^{T}\) (inverse is the same as transpose, inverse then transpose again). However if you are a column major guy like myself, I have a full-on column major version for you in <a href="#_appendix">Appendix</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_transform_matrix_inverse">Transform Matrix Inverse</h3>
<div class="paragraph">
<p>The transform matrix we are talking about here is defined as following:</p>
</div>
<div class="stemblock">
<div class="content">
\[M=\left( \begin{matrix} a\vec{X} &amp; 0 \\ b\vec{Y} &amp; 0 \\ c\vec{Z} &amp; 0 \\ \vec{T} &amp; 1 \\ \end{matrix} \right) = \left( \begin{matrix} aX_0 &amp; aX_1 &amp; aX_2 &amp; 0 \\ bY_0 &amp; bY_1 &amp; bY_2 &amp; 0 \\ cZ_0 &amp; cZ_1 &amp; cZ_2 &amp; 0 \\ T_0 &amp; T_1 &amp; T_2 &amp; 1 \\ \end{matrix} \right)\]
</div>
</div>
<div class="paragraph">
<p>The first 3 component of the last row is the translation \(\vec{T}\). The top left 3x3 sub-matrix is the scaled rotation matrix, with each row as a scaled axis. We have \(\vec{X}\cdot\vec{Y}=\vec{X}\cdot\vec{Z}=\vec{Y}\cdot\vec{Z}=0\), and \(\left|\vec{X}\right|=\left|\vec{Y}\right|=\left|\vec{Z}\right|=1\). And the scale is \((a,b,c)\).</p>
</div>
<div class="paragraph">
<p>Most matrices in the game are of this form. For example, \(M\) represents a local to world transform, \(\vec{X}\), \(\vec{Y}\), \(\vec{Z}\) are your local space axes. If you have a point \(\vec{P}(P_0,P_1,P_2)\), and you want to transform it from local space to world space, you do this:</p>
</div>
<div class="stemblock">
<div class="content">
\[\vec{P'}=P_0a\vec{X}+P_1b\vec{Y}+P_2c\vec{Z}+\vec{T}\]
</div>
</div>
<div class="paragraph">
<p>This is the same as extend \(\vec{P}\) to a 4 component vector \(\vec{P}(P_0,P_1,P_2,1)\) and multiply by matrix \(M\). Now what does inverse matrix \(M^{-1}\) mean? In this case it represents a world to local transform, so if we multiply \(\vec{P'}\) by \(M^{-1}\), we should get \(\vec{P}\) back. How do we transform the point \(\vec{P'}\) from world space back in local space? We subtract the local space origin (aka the translation \(\vec{T}\)), then dot each axes to get its local space coordinate and rescale it:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
\vec{P}&amp;=(\frac{1}{a}(\vec{P'}-\vec{T})\cdot\vec{X},\frac{1}{b}(\vec{P'}-\vec{T})\cdot\vec{Y},\frac{1}{c}(\vec{P'}-\vec{T})\cdot\vec{Z})\\
&amp;=(\frac{1}{a}\vec{P'}\cdot\vec{X},\frac{1}{b}\vec{P'}\cdot\vec{Y},\frac{1}{c}\vec{P'}\cdot\vec{Z})-(\frac{1}{a}\vec{T}\cdot\vec{X},\frac{1}{b}\vec{T}\cdot\vec{Y},\frac{1}{c}\vec{T}\cdot\vec{Z})
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>With this, we can actually directly write the form of the inverse of our matrix.</p>
</div>
<div class="stemblock">
<div class="content">
\[M^{-1}=\left( \begin{matrix} \frac{1}{a}\vec{X} &amp; \frac{1}{b}\vec{Y} &amp; \frac{1}{c}\vec{Z} &amp; \vec{0} \\ -\vec{T}\cdot\frac{1}{a}\vec{X} &amp; -\vec{T}\cdot\frac{1}{b}\vec{Y} &amp; -\vec{T}\cdot\frac{1}{c}\vec{Z} &amp; 1 \\ \end{matrix} \right) = \left( \begin{matrix} \frac{1}{a}X_0 &amp; \frac{1}{b}Y_0 &amp; \frac{1}{c}Z_0 &amp; 0 \\ \frac{1}{a}X_1 &amp; \frac{1}{b}Y_1 &amp; \frac{1}{c}Z_1 &amp; 0 \\ \frac{1}{a}X_2 &amp; \frac{1}{b}Y_2 &amp; \frac{1}{c}Z_2 &amp; 0 \\ -\vec{T}\cdot\frac{1}{a}\vec{X} &amp; -\vec{T}\cdot\frac{1}{b}\vec{Y} &amp; -\vec{T}\cdot\frac{1}{c}\vec{Z} &amp; 1 \\ \end{matrix} \right)\]
</div>
</div>
<div class="paragraph">
<p>The nice thing about transform matrix \(M\) is its first 3 rows are perpendicular to each other. Its inverse form is basically transpose the 3x3 rotation matrix, and rescale it, and change translation part by doing dot product with 3 rescaled axes. It should be easy to confirm \(MM^{-1}=I\).</p>
</div>
<div class="paragraph">
<p>Now let’s bake in the scale (so \(\left|\vec{X}\right|=a\),\(\left|\vec{Y}\right|=b\),\(\left|\vec{Z}\right|=c\)) and get a more generic form.</p>
</div>
<div class="stemblock">
<div class="content">
\[M=\left( \begin{matrix} \vec{X} &amp; 0 \\ \vec{Y} &amp; 0 \\ \vec{Z} &amp; 0 \\ \vec{T} &amp; 1 \\ \end{matrix} \right), M^{-1}=\left( \begin{matrix} \frac{1}{{\left|\vec{X}\right|}^{2}}\vec{X} &amp; \frac{1}{{\left|\vec{Y}\right|}^{2}}\vec{Y} &amp; \frac{1}{{\left|\vec{Z}\right|}^{2}}\vec{Z} &amp; \vec{0} \\ -\vec{T}\cdot\frac{1}{{\left|\vec{X}\right|}^{2}}\vec{X} &amp; -\vec{T}\cdot\frac{1}{{\left|\vec{Y}\right|}^{2}}\vec{Y} &amp; -\vec{T}\cdot\frac{1}{{\left|\vec{Z}\right|}^{2}}\vec{Z} &amp; 1 \\ \end{matrix} \right)\]
</div>
</div>
<div class="paragraph">
<p>Notice that for rescaling, we divide by squared size of scaled axis, instead of size, which is good news for implementation. And if our transform is of unit scale, which is also common in games, our target becomes even simpler.</p>
</div>
<div class="stemblock">
<div class="content">
\[M^{-1}=\left( \begin{matrix} \vec{X} &amp; \vec{Y} &amp; \vec{Z} &amp; \vec{0} \\ -\vec{T}\cdot\vec{X} &amp; -\vec{T}\cdot\vec{Y} &amp; -\vec{T}\cdot\vec{Z} &amp; 1 \\ \end{matrix} \right)\]
</div>
</div>
<div class="paragraph">
<p>Alright, enough theory, let’s see some code. This is our matrix definition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">__declspec(align(16)) struct Matrix4
{
public:
	union
	{
		float m[4][4];
		__m128 mVec[4];
	};
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Before we jump in intrinsics, I would like to define a bunch of shuffle/swizzle macros. Hopefully they will make it easier to read. We also make use of faster instructions for special shuffles.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">#define MakeShuffleMask(x,y,z,w)           (x | (y&lt;&lt;2) | (z&lt;&lt;4) | (w&lt;&lt;6))

// vec(0, 1, 2, 3) -&gt; (vec[x], vec[y], vec[z], vec[w])
#define VecSwizzle(vec, x,y,z,w)           _mm_shuffle_ps(vec, vec, MakeShuffleMask(x,y,z,w))
#define VecSwizzle1(vec, x)                _mm_shuffle_ps(vec, vec, MakeShuffleMask(x,x,x,x))
// special swizzle
#define VecSwizzle_0101(vec)               _mm_movelh_ps(vec, vec)
#define VecSwizzle_2323(vec)               _mm_movehl_ps(vec, vec)
#define VecSwizzle_0022(vec)               _mm_moveldup_ps(vec)
#define VecSwizzle_1133(vec)               _mm_movehdup_ps(vec)

// return (vec1[x], vec1[y], vec2[z], vec2[w])
#define VecShuffle(vec1, vec2, x,y,z,w)    _mm_shuffle_ps(vec1, vec2, MakeShuffleMask(x,y,z,w))
// special shuffle
#define VecShuffle_0101(vec1, vec2)        _mm_movelh_ps(vec1, vec2)
#define VecShuffle_2323(vec1, vec2)        _mm_movehl_ps(vec2, vec1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is our first function to inverse transform matrix without scaling (always unit scale).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">// Requires this matrix to be transform matrix, NoScale version requires this matrix be of scale 1
inline Matrix4 GetTransformInverseNoScale(const Matrix4&amp; inM)
{
	Matrix4 r;

	// transpose 3x3, we know m03 = m13 = m23 = 0
	__m128 t0 = VecShuffle_0101(inM.mVec[0], inM.mVec[1]); // 00, 01, 10, 11
	__m128 t1 = VecShuffle_2323(inM.mVec[0], inM.mVec[1]); // 02, 03, 12, 13
	r.mVec[0] = VecShuffle(t0, inM.mVec[2], 0,2,0,3); // 00, 10, 20, 23(=0)
	r.mVec[1] = VecShuffle(t0, inM.mVec[2], 1,3,1,3); // 01, 11, 21, 23(=0)
	r.mVec[2] = VecShuffle(t1, inM.mVec[2], 0,2,2,3); // 02, 12, 22, 23(=0)

	// last line
	r.mVec[3] =                       _mm_mul_ps(r.mVec[0], VecSwizzle1(inM.mVec[3], 0));
	r.mVec[3] = _mm_add_ps(r.mVec[3], _mm_mul_ps(r.mVec[1], VecSwizzle1(inM.mVec[3], 1)));
	r.mVec[3] = _mm_add_ps(r.mVec[3], _mm_mul_ps(r.mVec[2], VecSwizzle1(inM.mVec[3], 2)));
	r.mVec[3] = _mm_sub_ps(_mm_setr_ps(0.f, 0.f, 0.f, 1.f), r.mVec[3]);

	return r;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Very straight forward. This is the fastest function you can have, it only does a transpose and some dot products. If we add in scales, it takes a little more time to do rescaling, but still pretty fast. There is a little trick for calculating squared size, we can make use of the fact that we need to transpose 3x3 rotation part anyway, do squared size after and calculate 3 axes in one go.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">#define SMALL_NUMBER		(1.e-8f)

// Requires this matrix to be transform matrix
inline Matrix4 GetTransformInverse(const Matrix4&amp; inM)
{
	Matrix4 r;

	// transpose 3x3, we know m03 = m13 = m23 = 0
	__m128 t0 = VecShuffle_0101(inM.mVec[0], inM.mVec[1]); // 00, 01, 10, 11
	__m128 t1 = VecShuffle_2323(inM.mVec[0], inM.mVec[1]); // 02, 03, 12, 13
	r.mVec[0] = VecShuffle(t0, inM.mVec[2], 0,2,0,3); // 00, 10, 20, 23(=0)
	r.mVec[1] = VecShuffle(t0, inM.mVec[2], 1,3,1,3); // 01, 11, 21, 23(=0)
	r.mVec[2] = VecShuffle(t1, inM.mVec[2], 0,2,2,3); // 02, 12, 22, 23(=0)

	// (SizeSqr(mVec[0]), SizeSqr(mVec[1]), SizeSqr(mVec[2]), 0)
	__m128 sizeSqr;
	sizeSqr =                     _mm_mul_ps(r.mVec[0], r.mVec[0]);
	sizeSqr = _mm_add_ps(sizeSqr, _mm_mul_ps(r.mVec[1], r.mVec[1]));
	sizeSqr = _mm_add_ps(sizeSqr, _mm_mul_ps(r.mVec[2], r.mVec[2]));

	// optional test to avoid divide by 0
	__m128 one = _mm_set1_ps(1.f);
	// for each component, if(sizeSqr &lt; SMALL_NUMBER) sizeSqr = 1;
	__m128 rSizeSqr = _mm_blendv_ps(
		_mm_div_ps(one, sizeSqr),
		one,
		_mm_cmplt_ps(sizeSqr, _mm_set1_ps(SMALL_NUMBER))
		);

	r.mVec[0] = _mm_mul_ps(r.mVec[0], rSizeSqr);
	r.mVec[1] = _mm_mul_ps(r.mVec[1], rSizeSqr);
	r.mVec[2] = _mm_mul_ps(r.mVec[2], rSizeSqr);

	// last line
	r.mVec[3] =                       _mm_mul_ps(r.mVec[0], VecSwizzle1(inM.mVec[3], 0));
	r.mVec[3] = _mm_add_ps(r.mVec[3], _mm_mul_ps(r.mVec[1], VecSwizzle1(inM.mVec[3], 1)));
	r.mVec[3] = _mm_add_ps(r.mVec[3], _mm_mul_ps(r.mVec[2], VecSwizzle1(inM.mVec[3], 2)));
	r.mVec[3] = _mm_sub_ps(_mm_setr_ps(0.f, 0.f, 0.f, 1.f), r.mVec[3]);

	return r;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice the top and bottom of the function is exactly the same as the NoScale version. In the middle we calculate squared size, with an optional divide-by-small-number test.</p>
</div>
</div>
<div class="sect2">
<h3 id="_general_matrix_inverse">General Matrix Inverse</h3>
<div class="paragraph">
<p>For general matrix, things are getting complicated. You can find most of the theory part in the following wiki pages:
<a href="https://en.wikipedia.org/wiki/Invertible_matrix">Invertible Matrix</a>, <a href="https://en.wikipedia.org/wiki/Adjugate_matrix">Adjugate Matrix</a>, <a href="https://en.wikipedia.org/wiki/Determinant#Relation_to_eigenvalues_and_trace">Determinant</a>, <a href="https://en.wikipedia.org/wiki/Trace_(linear_algebra)">Trace</a>.</p>
</div>
<div class="paragraph">
<p>We will introduce some of them as we go. The method is based on the same block matrices method Intel used for its <a href="https://software.intel.com/en-us/articles/optimized-matrix-library-for-use-with-the-intel-pentiumr-4-processors-sse2-instructions/">Optimized Matrix Library</a>.</p>
</div>
<div class="paragraph">
<p>A 4x4 matrix can be described as 4 2x2 sub matrices. The good things about 2x2 matrix are not only it is easy to calculate their inverse or determinant, but also because they can fit in one vector register, their calculation can be done very fast.</p>
</div>
<div class="stemblock">
<div class="content">
\[M=\left( \begin{matrix} A &amp; B \\ C &amp; D \\ \end{matrix} \right)=\left( \begin{matrix} A_0 &amp; A_1 &amp; B_0 &amp; B_1 \\ A_2 &amp; A_3 &amp; B_2 &amp; B_3 \\ C_0 &amp; C_1 &amp; D_0 &amp; D_1 \\ C_2 &amp; C_3 &amp; D_2 &amp; D_3 \\ \end{matrix} \right)\]
</div>
</div>
<div class="paragraph">
<p>Matrix block-wise inverse is given by the following:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
{\left( \begin{matrix} A &amp; B \\ C &amp; D \\ \end{matrix} \right)}^{-1}&amp;=\left( \begin{matrix} A^{-1}+A^{-1}B(D-CA^{-1}B)^{-1}CA^{-1} &amp; -A^{-1}B(D-CA^{-1}B)^{-1} \\ -(D-CA^{-1}B)^{-1}CA^{-1} &amp; (D-CA^{-1}B)^{-1} \\ \end{matrix} \right)\\
&amp;=\left( \begin{matrix} (A-BD^{-1}C)^{-1} &amp; -(A-BD^{-1}C)^{-1}BD^{-1} \\ -D^{-1}C(A-BD^{-1}C)^{-1} &amp; D^{-1}+D^{-1}C(A-BD^{-1}C)^{-1}BD^{-1} \\ \end{matrix} \right)
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>We actually use a mix of these two forms, 2nd row from the first form, and 1st row from the second form.</p>
</div>
<div class="stemblock">
<div class="content">
\[{\left( \begin{matrix} A &amp; B \\ C &amp; D \\ \end{matrix} \right)}^{-1}=\left( \begin{matrix} (A-BD^{-1}C)^{-1} &amp; -(A-BD^{-1}C)^{-1}BD^{-1} \\ -(D-CA^{-1}B)^{-1}CA^{-1} &amp; (D-CA^{-1}B)^{-1} \\ \end{matrix} \right)\]
</div>
</div>
<div class="paragraph">
<p>This choice might not seem obvious. Take the first form for example, it seems we only need to calculate two 2x2 matrix inverse: \(A^{-1}\) and \((D-CA^{-1} B)^{-1}\), however it can be further simplified by proper derivation. Since each corresponding sub-matrix equals to each other, it doesn’t matter which form you choose to work your math on. We just select the easier row from both forms.</p>
</div>
<div class="paragraph">
<p>Before we start derivation, we need to introduce some concepts. The adjugate of matrix \(A\) is defined as \(A\operatorname{adj}(A)=\left|A\right|I\), where \(\left|A\right|\) is determinant of \(A\). For convenience, in this post we denote adjugate matrix as \(A^{\#}=\operatorname{adj}(A)\). So we can change inverse calculation to adjugate calculation by \(A^{-1}=\frac{1}{\left|A\right|}A^{\#}\). Adjugate of 2x2 matrix is:</p>
</div>
<div class="stemblock">
<div class="content">
\[A^{\#}={\left( \begin{matrix} A_0 &amp; A_1 \\ A_2 &amp; A_3 \\ \end{matrix} \right)}^{\#}=\left( \begin{matrix} A_3 &amp; -A_1 \\ -A_2 &amp; A_0 \\ \end{matrix} \right)\]
</div>
</div>
<div class="paragraph">
<p>Adjugate of 2x2 matrix has the following property: \((AB)^{\#}=B^{\#}A^{\#}\),\((A^{\#})^{\#}=A\), \((cA)^{\#}=cA^{\#}\).</p>
</div>
<div class="paragraph">
<p>For determinant of 2x2 matrix, we will use the following properties: \(\left|A\right|={A_0}{A_3}-{A_1}{A_2}\), \(\left|-A\right|=\left|A\right|\), \(\left|AB\right|=\left|A\right|\left|B\right|\), \(\left|A+B\right|=\left|A\right| + \left|B\right| + \operatorname{tr}(A^{\#}{B})\).</p>
</div>
<div class="paragraph">
<p>For trace of matrix we have \(\operatorname{tr}(AB)=\operatorname{tr}(BA)\), \(\operatorname{tr}(-A)=-\operatorname{tr}(A)\).</p>
</div>
<div class="paragraph">
<p>Finally for our block matrices \(M={\left( \begin{matrix} A &amp; B \\ C &amp; D \\ \end{matrix} \right)}\), the determinant is</p>
</div>
<div class="stemblock">
<div class="content">
\[\left|M\right|=\left|A\right|\left|D-CA^{-1}B\right|=\left|D\right|\left|A-BD^{-1}C\right|=\left|AD-BC\right|\]
</div>
</div>
<div class="paragraph">
<p>I only listed properties needed for derivation. If you are not familiar with these concepts, or want to know more about them, take a look at the wiki pages above.</p>
</div>
<div class="paragraph">
<p>Let \(M^{-1}={\left( \begin{matrix} A &amp; B \\ C &amp; D \\ \end{matrix} \right)}^{-1}={\left( \begin{matrix} X &amp; Y \\ Z &amp; W \\ \end{matrix} \right)}\).Let’s start with the top left corner.</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
X&amp;=(A-BD^{-1}C)^{-1}\\
&amp;=\frac{1}{\left|A-BD^{-1}C\right|}(A-\frac{1}{\left|D\right|}BD^{\#}C)^{\#}\\
&amp;=\frac{1}{\left|D\right|\left|A-BD^{-1}C\right|}(\left|D\right|A-BD^{\#}C)^{\#}\\
&amp;=\frac{1}{\left|M\right|}(\left|D\right|A-B(D^{\#}C))^{\#}
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Similarly we can derive the bottom right corner:</p>
</div>
<div class="stemblock">
<div class="content">
\[W=(D-CA^{-1}B)^{-1}=\frac{1}{\left|M\right|}(\left|A\right|D-C(A^{\#}B))^{\#}\]
</div>
</div>
<div class="paragraph">
<p>Notice that we put parentheses around \(D^{\#}C\) and \(A^{\#}B\), and you will see the reason soon.</p>
</div>
<div class="paragraph">
<p>Now let’s do the top right corner, and make use of the result of top left corner \(X\):</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
Y&amp;=-(A-BD^{-1}C)^{-1}BD^{-1}\\
&amp;=-\frac{1}{\left|M\right|\left|D\right|}(\left|D\right|A-B(D^{\#}C))^{\#}(BD^{\#})\\
&amp;=-\frac{1}{\left|M\right|\left|D\right|}(\left|D\right|A-B(D^{\#}C))^{\#}(DB^{\#})^{\#}\\
&amp;=-\frac{1}{\left|M\right|\left|D\right|}(\left|D\right|DB^{\#}A-DB^{\#}B(D^{\#}C))^{\#}\\
&amp;=-\frac{1}{\left|M\right|\left|D\right|}(\left|D\right|D(A^{\#}B)^{\#}-\left|D\right|\left|B\right|C))^{\#}\\
&amp;=\frac{1}{\left|M\right|}(\left|B\right|C-D(A^{\#}B)^{\#})^{\#}
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Similarly we can derive the bottom left corner:</p>
</div>
<div class="stemblock">
<div class="content">
\[Z=-(D-CA^{-1}B)^{-1}CA^{-1}=\frac{1}{\left|M\right|}(\left|C\right|B-A(D^{\#}C)^{\#})^{\#}\]
</div>
</div>
<div class="paragraph">
<p>Here we also changed from \(B^{\#}A\) to \((A^{\#}B)^{\#}\), so we can reuse the result of \(A^{\#}B\). Putting them together:</p>
</div>
<div class="stemblock">
<div class="content">
\[M^{-1}={\left( \begin{matrix} A &amp; B \\ C &amp; D \\ \end{matrix} \right)}^{-1}=\frac{1}{\left|M\right|}{\left( \begin{matrix} (\left|D\right|A-B(D^{\#}C))^{\#} &amp; (\left|B\right|C-D(A^{\#}B)^{\#})^{\#} \\ (\left|C\right|B-A(D^{\#}C)^{\#})^{\#} &amp; (\left|A\right|D-C(A^{\#}B))^{\#} \\ \end{matrix} \right)}\]
</div>
</div>
<div class="paragraph">
<p>Now it is clear what kind of calculation we need. We need 2x2 matrix multiply and multiply by adjugate: \(AB\), \(A^{\#}B\) and \(AB^{\#}\). We already know how to do adjugate, but in this case, adjugate can be combined with multiplication so we don’t waste instructions. Just expand the result and rearrange the order, for example:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
A^{\#}B&amp;={\left( \begin{matrix} A_3 &amp; -A_1 \\ -A_2 &amp; A_0 \\ \end{matrix} \right)}{\left( \begin{array}{} B_0 &amp; B_1 \\ B_2 &amp; B_3 \\ \end{array} \right)}\\
&amp;={\left( \begin{array}{} {A_3}{B_0}-{A_1}{B_2} &amp;{A_3}{B_1}-{A_1}{B_3} \\ {A_0}{B_2}-{A_2}{B_0} &amp; {A_0}{B_3}-{A_2}{B_1} \\ \end{array} \right)}
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Here’s the code for these three functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">// for row major matrix
// we use __m128 to represent 2x2 matrix as A = | A0  A1 |
//                                              | A2  A3 |
// 2x2 row major Matrix multiply A*B
__forceinline __m128 Mat2Mul(__m128 vec1, __m128 vec2)
{
	return
		_mm_add_ps(_mm_mul_ps(                     vec1, VecSwizzle(vec2, 0,3,0,3)),
		           _mm_mul_ps(VecSwizzle(vec1, 1,0,3,2), VecSwizzle(vec2, 2,1,2,1)));
}
// 2x2 row major Matrix adjugate multiply (A#)*B
__forceinline __m128 Mat2AdjMul(__m128 vec1, __m128 vec2)
{
	return
		_mm_sub_ps(_mm_mul_ps(VecSwizzle(vec1, 3,3,0,0), vec2),
		           _mm_mul_ps(VecSwizzle(vec1, 1,1,2,2), VecSwizzle(vec2, 2,3,0,1)));

}
// 2x2 row major Matrix multiply adjugate A*(B#)
__forceinline __m128 Mat2MulAdj(__m128 vec1, __m128 vec2)
{
	return
		_mm_sub_ps(_mm_mul_ps(                     vec1, VecSwizzle(vec2, 3,0,3,0)),
		           _mm_mul_ps(VecSwizzle(vec1, 1,0,3,2), VecSwizzle(vec2, 2,1,2,1)));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another trick is after we calculate the 2x2 sub matrix, for example \(\left|D\right|A-B(D^{\#}C)\), the final adjugate to get \(X=(\left|D\right|A-B(D^{\#}C))^{\#}\) can be combined with storing 2x2 sub matrices to the final result 4x4 matrix. You can see this at the end of the function.</p>
</div>
<div class="paragraph">
<p>The only thing left if determinant. 2x2 determinant is easy, the problem really is the whole 4x4 matrix determinant. Remember the determinant property we give above:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
\left|M\right|&amp;=\left|AD-BC\right|\\
&amp;=\left|AD\right|+\left|-BC\right|+\operatorname{tr}((AD)^{\#}(-BC))\\
&amp;=\left|A\right|\left|D\right|+\left|B\right|\left|C\right|-\operatorname{tr}(D^{\#}A^{\#}BC)\\
&amp;=\left|A\right|\left|D\right|+\left|B\right|\left|C\right|-\operatorname{tr}((A^{\#}B)(D^{\#}C))
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>This is good. We need to calculate all sub matrices determinants and matrix \(A^{\#}B\) and \(D^{\#}C\) anyway. And if you derive the trace of 2x2 matrix multiplication:</p>
</div>
<div class="stemblock">
<div class="content">
\[\operatorname{tr}(AB)={A_0}{B_0}+{A_1}{B_2}+{A_2}{B_1}+{A_3}{B_3}\]
</div>
</div>
<div class="paragraph">
<p>This is just a shuffle and a dot product, should be easy enough to translate into instructions.</p>
</div>
<div class="paragraph">
<p>Now we have all pieces ready, here is our function for general 4x4 matrix inverse:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">// Inverse function is the same no matter column major or row major
// this version treats it as row major
inline Matrix4 GetInverse(const Matrix4&amp; inM)
{
	// use block matrix method
	// A is a matrix, then i(A) or iA means inverse of A, A# (or A_ in code) means adjugate of A, |A| (or detA in code) is determinant, tr(A) is trace

	// sub matrices
	__m128 A = VecShuffle_0101(inM.mVec[0], inM.mVec[1]);
	__m128 B = VecShuffle_2323(inM.mVec[0], inM.mVec[1]);
	__m128 C = VecShuffle_0101(inM.mVec[2], inM.mVec[3]);
	__m128 D = VecShuffle_2323(inM.mVec[2], inM.mVec[3]);

	__m128 detA = _mm_set1_ps(inM.m[0][0] * inM.m[1][1] - inM.m[0][1] * inM.m[1][0]);
	__m128 detB = _mm_set1_ps(inM.m[0][2] * inM.m[1][3] - inM.m[0][3] * inM.m[1][2]);
	__m128 detC = _mm_set1_ps(inM.m[2][0] * inM.m[3][1] - inM.m[2][1] * inM.m[3][0]);
	__m128 detD = _mm_set1_ps(inM.m[2][2] * inM.m[3][3] - inM.m[2][3] * inM.m[3][2]);

#if 0 // for determinant, float version is faster
	// determinant as (|A| |B| |C| |D|)
	__m128 detSub = _mm_sub_ps(
		_mm_mul_ps(VecShuffle(inM.mVec[0], inM.mVec[2], 0,2,0,2), VecShuffle(inM.mVec[1], inM.mVec[3], 1,3,1,3)),
		_mm_mul_ps(VecShuffle(inM.mVec[0], inM.mVec[2], 1,3,1,3), VecShuffle(inM.mVec[1], inM.mVec[3], 0,2,0,2))
	);
	__m128 detA = VecSwizzle1(detSub, 0);
	__m128 detB = VecSwizzle1(detSub, 1);
	__m128 detC = VecSwizzle1(detSub, 2);
	__m128 detD = VecSwizzle1(detSub, 3);
#endif

	// let iM = 1/|M| * | X  Y |
	//                  | Z  W |

	// D#C
	__m128 D_C = Mat2AdjMul(D, C);
	// A#B
	__m128 A_B = Mat2AdjMul(A, B);
	// X# = |D|A - B(D#C)
	__m128 X_ = _mm_sub_ps(_mm_mul_ps(detD, A), Mat2Mul(B, D_C));
	// W# = |A|D - C(A#B)
	__m128 W_ = _mm_sub_ps(_mm_mul_ps(detA, D), Mat2Mul(C, A_B));

	// |M| = |A|*|D| + ... (continue later)
	__m128 detM = _mm_mul_ps(detA, detD);

	// Y# = |B|C - D(A#B)#
	__m128 Y_ = _mm_sub_ps(_mm_mul_ps(detB, C), Mat2MulAdj(D, A_B));
	// Z# = |C|B - A(D#C)#
	__m128 Z_ = _mm_sub_ps(_mm_mul_ps(detC, B), Mat2MulAdj(A, D_C));

	// |M| = |A|*|D| + |B|*|C| ... (continue later)
	detM = _mm_add_ps(detM, _mm_mul_ps(detB, detC));

	// tr((A#B)(D#C))
	__m128 tr = _mm_mul_ps(A_B, VecSwizzle(D_C, 0,2,1,3));
	tr = _mm_hadd_ps(tr, tr);
	tr = _mm_hadd_ps(tr, tr);
	// |M| = |A|*|D| + |B|*|C| - tr((A#B)(D#C)
	detM = _mm_sub_ps(detM, tr);

	const __m128 adjSignMask = _mm_setr_ps(1.f, -1.f, -1.f, 1.f);
	// (1/|M|, -1/|M|, -1/|M|, 1/|M|)
	__m128 rDetM = _mm_div_ps(adjSignMask, detM);

	X_ = _mm_mul_ps(X_, rDetM);
	Y_ = _mm_mul_ps(Y_, rDetM);
	Z_ = _mm_mul_ps(Z_, rDetM);
	W_ = _mm_mul_ps(W_, rDetM);

	Matrix4 r;

	// apply adjugate and store, here we combine adjugate shuffle and store shuffle
	r.mVec[0] = VecShuffle(X_, Y_, 3,1,3,1);
	r.mVec[1] = VecShuffle(X_, Y_, 2,0,2,0);
	r.mVec[2] = VecShuffle(Z_, W_, 3,1,3,1);
	r.mVec[3] = VecShuffle(Z_, W_, 2,0,2,0);

	return r;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As side products of this function, it also gives you optimized version of calculating determinant and adjugate of 4x4 matrix. There are two things I want to talk a little bit more.</p>
</div>
<div class="paragraph">
<p>When we calculate the determinants of sub matrices, I do have a version to calculate 4 determinants in one go. However calculate them separately and use _mm_set1_ps to load into vector unit is proven to be faster on my CPU. My guess is since we need them to be separated anyway, even if I can calculate them together I need to use 4 shuffles to separate them out, which is not worth the effort, but I’m not sure. You should test performance in both versions.</p>
</div>
<div class="paragraph">
<p>Also when calculating trace, I’m using two _mm_hadd_ps to sum up 4 components and have the result in all 4 components. There are a lot of ways to do the same thing. From what I tested, they yield similar performance, so I choose the one with less instructions. Again it could be different on different target platforms, and you should test them.</p>
</div>
<div class="paragraph">
<p>So how our functions perform? The following measurement and comparison is done in August 2017. We use __rdtsc to count cycles. For each test we loop 10 million times and measure the average cycle counts. We do 5 groups of tests and here is the result on Intel Haswell:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="https://github.com/lxjk/lxjk.github.io/raw/master/images/matrixinverse/fig1.jpg" alt="fig1.jpg" width="600">
</div>
<div class="title">Figure 1</div>
</div>
<div class="paragraph">
<p>The first three columns are our 3 versions of functions. The SIMD version of general 4x4 matrix inverse only cost less than half (44%) of the float version. And if you know the matrix is a transform matrix, it would cost less than a quarter (21%) of the float version. The more information you have as a programmer, the less work the machine need to do.</p>
</div>
<div class="paragraph">
<p>Think about that question again, do we really need to inverse a matrix. If we are using transform matrix and all we do is inverse transform a point or vector temporarily (so no need to save inverse matrix for other calculations), write an inverse transform function, which is faster than get inverse matrix and then transform. Hopefully this will help you choose which function to write or use, and how to make it fast.</p>
</div>
</div>
<div class="sect2">
<h3 id="_appendix">Appendix</h3>
<div class="paragraph">
<p>This is column major area. The first two functions for transform matrix is exactly the same in column major. Here is the general matrix inverse and helper functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">// for column major matrix
// we use __m128 to represent 2x2 matrix as A = | A0  A2 |
//                                              | A1  A3 |
// 2x2 column major Matrix multiply A*B
__forceinline __m128 Mat2Mul(__m128 vec1, __m128 vec2)
{
	return
		_mm_add_ps(_mm_mul_ps(                     vec1, VecSwizzle(vec2, 0,0,3,3)),
		           _mm_mul_ps(VecSwizzle(vec1, 2,3,0,1), VecSwizzle(vec2, 1,1,2,2)));
}
// 2x2 column major Matrix adjugate multiply (A#)*B
__forceinline __m128 Mat2AdjMul(__m128 vec1, __m128 vec2)
{
	return
		_mm_sub_ps(_mm_mul_ps(VecSwizzle(vec1, 3,0,3,0), vec2),
		           _mm_mul_ps(VecSwizzle(vec1, 2,1,2,1), VecSwizzle(vec2, 1,0,3,2)));

}
// 2x2 column major Matrix multiply adjugate A*(B#)
__forceinline __m128 Mat2MulAdj(__m128 vec1, __m128 vec2)
{
	return
		_mm_sub_ps(_mm_mul_ps(                     vec1, VecSwizzle(vec2, 3,3,0,0)),
		           _mm_mul_ps(VecSwizzle(vec1, 2,3,0,1), VecSwizzle(vec2, 1,1,2,2)));
}

// Inverse function is the same no matter column major or row major
// this version treats it as column major
inline Matrix4 GetInverse(const Matrix4&amp; inM)
{
	// use block matrix method
	// A is a matrix, then i(A) or iA means inverse of A, A# (or A_ in code) means adjugate of A, |A| (or detA in code) is determinant, tr(A) is trace

	// sub matrices
	__m128 A = VecShuffle_0101(inM.mVec[0], inM.mVec[1]);
	__m128 C = VecShuffle_2323(inM.mVec[0], inM.mVec[1]);
	__m128 B = VecShuffle_0101(inM.mVec[2], inM.mVec[3]);
	__m128 D = VecShuffle_2323(inM.mVec[2], inM.mVec[3]);

	__m128 detA = _mm_set1_ps(inM.m[0][0] * inM.m[1][1] - inM.m[0][1] * inM.m[1][0]);
	__m128 detC = _mm_set1_ps(inM.m[0][2] * inM.m[1][3] - inM.m[0][3] * inM.m[1][2]);
	__m128 detB = _mm_set1_ps(inM.m[2][0] * inM.m[3][1] - inM.m[2][1] * inM.m[3][0]);
	__m128 detD = _mm_set1_ps(inM.m[2][2] * inM.m[3][3] - inM.m[2][3] * inM.m[3][2]);

#if 0 // for determinant, float version is faster
	// determinant as (|A| |C| |B| |D|)
	__m128 detSub = _mm_sub_ps(
		_mm_mul_ps(VecShuffle(inM.mVec[0], inM.mVec[2], 0,2,0,2), VecShuffle(inM.mVec[1], inM.mVec[3], 1,3,1,3)),
		_mm_mul_ps(VecShuffle(inM.mVec[0], inM.mVec[2], 1,3,1,3), VecShuffle(inM.mVec[1], inM.mVec[3], 0,2,0,2))
		);
	__m128 detA = VecSwizzle1(detSub, 0);
	__m128 detC = VecSwizzle1(detSub, 1);
	__m128 detB = VecSwizzle1(detSub, 2);
	__m128 detD = VecSwizzle1(detSub, 3);
#endif

	// let iM = 1/|M| * | X  Y |
	//                  | Z  W |

	// D#C
	__m128 D_C = Mat2AdjMul(D, C);
	// A#B
	__m128 A_B = Mat2AdjMul(A, B);
	// X# = |D|A - B(D#C)
	__m128 X_ = _mm_sub_ps(_mm_mul_ps(detD, A), Mat2Mul(B, D_C));
	// W# = |A|D - C(A#B)
	__m128 W_ = _mm_sub_ps(_mm_mul_ps(detA, D), Mat2Mul(C, A_B));

	// |M| = |A|*|D| + ... (continue later)
	__m128 detM = _mm_mul_ps(detA, detD);

	// Y# = |B|C - D(A#B)#
	__m128 Y_ = _mm_sub_ps(_mm_mul_ps(detB, C), Mat2MulAdj(D, A_B));
	// Z# = |C|B - A(D#C)#
	__m128 Z_ = _mm_sub_ps(_mm_mul_ps(detC, B), Mat2MulAdj(A, D_C));

	// |M| = |A|*|D| + |B|*|C| ... (continue later)
	detM = _mm_add_ps(detM, _mm_mul_ps(detB, detC));

	// tr((A#B)(D#C))
	__m128 tr = _mm_mul_ps(A_B, VecSwizzle(D_C, 0,2,1,3));
	tr = _mm_hadd_ps(tr, tr);
	tr = _mm_hadd_ps(tr, tr);
	// |M| = |A|*|D| + |B|*|C| - tr((A#B)(D#C))
	detM = _mm_sub_ps(detM, tr);

	const __m128 adjSignMask = _mm_setr_ps(1.f, -1.f, -1.f, 1.f));
	// (1/|M|, -1/|M|, -1/|M|, 1/|M|)
	__m128 rDetM = _mm_div_ps(adjSignMask, detM);

	X_ = _mm_mul_ps(X_, rDetM);
	Y_ = _mm_mul_ps(Y_, rDetM);
	Z_ = _mm_mul_ps(Z_, rDetM);
	W_ = _mm_mul_ps(W_, rDetM);

	Matrix4 r;

	// apply adjugate and store, here we combine adjugate shuffle and store shuffle
	r.mVec[0] = VecShuffle(X_, Z_, 3,1,3,1);
	r.mVec[1] = VecShuffle(X_, Z_, 2,0,2,0);
	r.mVec[2] = VecShuffle(Y_, W_, 3,1,3,1);
	r.mVec[3] = VecShuffle(Y_, W_, 2,0,2,0);

	return r;
}</code></pre>
</div>
</div>
</div>]]></description><link>https://lxjk.github.io/2017/09/03/Fast-4x4-Matrix-Inverse-with-SSE-SIMD-Explained.html</link><guid isPermaLink="true">https://lxjk.github.io/2017/09/03/Fast-4x4-Matrix-Inverse-with-SSE-SIMD-Explained.html</guid><category><![CDATA[Math]]></category><category><![CDATA[SSE]]></category><dc:creator><![CDATA[Eric Zhang]]></dc:creator><pubDate>Sun, 03 Sep 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Conversion between View Space Linear and Screen Space Linear]]></title><description><![CDATA[<div class="paragraph">
<p>Some background of this problem: when doing screen space reflection, we need to shoot a ray from every pixel to find out reflection color. However we don’t want to march the ray in view space, because for example you have a ray pointing relatively inwards or outwards to the screen, we may march a large distance in view space but only move a pixel in screen space. Since all information are stored in pixels, we are wasting time sampling the same pixel. The other way around, if the ray is pointing to X/Y axis in view space, we might miss pixels if we march too fast in view space. So in general it is a better idea to march the ray in screen space instead.</p>
</div>
<div class="paragraph">
<p>Now the problem becomes if we march to a point in screen space somewhere between start pixel and end pixel, what is the corresponding point in view space? Of course we can use projection matrix to un-project it back to view space, but since we already know start point and end point in view space, we can do better than that. Let’s define our problem more specifically:</p>
</div>
<div class="paragraph">
<p>We know two points in view space \(A_v\) and \(B_v\), their projected point in screen space is \(A_s\) and \(B_s\). In screen space, given a linear interpolation ratio \(r_s\) and a point \({P_s}={A_s}(1-{r_s}) + {{B_s}{r_s}}\), what is its corresponding point \(P_v\) in view space, and the ratio \(r_v\) such that \({P_v}={A_v}(1-{r_v})+{B_v}{r_v}\).</p>
</div>
<div class="paragraph">
<p>We will use OpenGL coordinate (right-handed, Y up), so \(A_v\) and \(B_v\) has negative Z value.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="https://github.com/lxjk/lxjk.github.io/raw/master/images/linearconversion/fig1.png" alt="fig1.png" width="400">
</div>
<div class="title">Figure 1</div>
</div>
<div class="paragraph">
<p>If you wonder why \(r_s\) and \(r_v\) are different, take a look at figure 1. \({r_v}=\frac{\left|AP\right|}{\left|AB\right|}\), while \({r_s}=\frac{\left|{A_1}{P_1}\right|}{\left|{A_1}{B_1}\right|}\), they are the same only if \(AB\) is parallel to \({A_1}{B_1}\).</p>
</div>
<div class="paragraph">
<p>First we want to simplify our problem a little bit. Recall how we project a point from view space to screen space, with projection matrix \(M\) and window size \(S\), for any point in view space \(Q_v\), we project it into clip space (range from -1 to 1): \({Q_c}=\frac{1}{(M{Q_v}).w}{M{Q_v}}\), then we remap it to screen space: \({Q_s}=\frac{1}{2}({Q_c} + 1)S\). Here \(S\) is constant, so screen space is just a linear combination of view space, which means the linear ratio doesn’t change from clip space to view space: \({P_c}={A_c}(1-{r_s})+{B_c}{r_s}\). We can ignore screen space remap, and just work on clip space.</p>
</div>
<div class="paragraph">
<p>Now take a look a figure 1 again, you can see since \(A{B_2}\) is parallel to \({A_1}{B_1}\), so \({r_s}=\frac{\left|{A_1}{P_1}\right|}{\left|{A_1}{B_1}\right|}=\frac{\left|A{P_2}\right|}{\left|A{B_2}\right|}\). It means the selection of near plane and far plane doesn’t affect linear ratio at all, because they are all parallel to each other. So we can choose a good pair of near and far plane to simplify the problem, for example let \(A_v\) be on near plane and \(B_v\) be on far plane: \(n=-{A_v}.z\), \(f=-{B_v}.z\) (Or the other way around if \(B_v\) is closer to camera, it doesn’t affect the result). Then in clip space we have</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
{A_c}.z&amp;=-1\\
{B_c}.z&amp;=1\\
{P_c}.z&amp;=({A_c}.z)(1-{r_s})+({B_c}.z){r_s}=2{r_s}-1
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>With these special Z values in clip space, if we find out \({P_v}.z\) in view space, we can get the view space linear ratio \({r_v}=\frac{{P_v}.z-{A_v}.z}{{B_v}.z-{A_v}.z}\).</p>
</div>
<div class="paragraph">
<p>Remember how perspective projection matrix is built:</p>
</div>
<div class="stemblock">
<div class="content">
\[M=\left( \begin{matrix} M_{00} &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; M_{11} &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; -\frac{f+n}{f-n} &amp; -\frac{2fn}{f-n} \\ 0 &amp; 0 &amp; -1 &amp; 0 \\ \end{matrix} \right) = \left( \begin{matrix} M_{00} &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; M_{11} &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; \frac{{A_v}.z+{B_v}.z}{{A_v}.z-{B_v}.z} &amp; -\frac{2({A_v}.z)({B_v}.z)}{{A_v}.z-{B_v}.z} \\ 0 &amp; 0 &amp; -1 &amp; 0 \\ \end{matrix} \right)\]
</div>
</div>
<div class="paragraph">
<p>If we only look at Z value of \(P_c\):</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
{P_c}.z&amp;=\frac{1}{(M{P_v}).w}(M{P_v}).z\\
&amp;=\frac{1}{-{P_v}.z}(\frac{{A_v}.z+{B_v}.z}{{A_v}.z-{B_v}.z}({P_v}.z)-\frac{2({A_v}.z)({B_v}.z)}{{A_v}.z-{B_v}.z})=2{r_s}-1
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Reorganize this equation, we can solve \({P_v}.z\)</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
({A_v}.z+{B_v}.z)({P_v}.z)-2({A_v}.z)({B_v}.z)&amp;=-(2{r_s}-1)({A_v}.z-{B_v}.z)({P_v}.z)\\
2(({B_v}.z)(1-{r_s})+({A_v}.z){r_s})({P_v}.z)&amp;=2({A_v}.z)({B_v}.z)
\end{align*}\]
</div>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
{P_v}.z&amp;=\frac{({A_v}.z)({B_v}.z)}{({B_v}.z)(1-{r_s})+({A_v}.z){r_s}}\\
&amp;=\frac{1}{\frac{1}{{A_v}.z}(1-{r_s})+\frac{1}{{B_v}.z}{r_s}}
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>When I got this result I was shocked, it turns out for any point \(P\) in screen space (or clip space) with a linear interpolation ratio \(r_s\) between two point \(A\) and \(B\), its linear depth \({P_v}.z\) is the reciprocal of a linear interpolation with the same ratio, but on the reciprocal of linear depth of \(A\) and \(B\). Seems too good to be true, but if you look back at the reason why view space linear is different than screen space linear, it is because we need to divide by the W value after multiplying projection matrix (multiplying projection matrix itself won’t change linear ratio), which is effectively multiply by \(\frac{1}{-{P_v}.z}\). It sort of make sense that in screen space, linear interpolation will operate on \(\frac{1}{{P_v}.z}\) instead, but sill amazing result.</p>
</div>
<div class="paragraph">
<p>Now we can calculate view space linear ratio:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
{r_v}&amp;=\frac{{P_v}.z-{A_v}.z}{{B_v}.z-{A_v}.z}\\
&amp;=\frac{({A_v}.z){r_s}}{({B_v}.z)(1-{r_s})+({A_v}.z){r_s}}\\
&amp;=\frac{\frac{1}{{B_v}.z}{r_s}}{\frac{1}{{A_v}.z}(1-{r_s})+\frac{1}{{B_v}.z}{r_s}}
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Inversely if we have view space linear ratio \(r_v\), we can calculate screen space linear ratio:</p>
</div>
<div class="stemblock">
<div class="content">
\[{r_s}=\frac{({B_v}.z){r_v}}{({A_v}.z)(1-{r_v})+({B_v}.z){r_v}}\]
</div>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="https://upload.wikimedia.org/wikipedia/commons/5/57/Perspective_correct_texture_mapping.jpg" alt="Perspective correct texture mapping.jpg" width="600">
</div>
<div class="title">Figure 2</div>
</div>
<div class="paragraph">
<p>As I’m writing this post, I just realize another classic use case of this conversion: <a href="https://en.wikipedia.org/wiki/Texture_mapping#Affine_texture_mapping">texture mapping</a>. If you simply use screen space interpolated UV to read texture, you will get distortion in perspective (called Affine texture mapping). To fix this you need to convert linear ratio into view space, which is exactly what we are doing here. You should be able to get same formula on wiki page for fixing UV on your own: \({u_α}=\frac{(1-α)\frac{u_0}{z_0} + α\frac{u_1}{z_1}}{(1-α)\frac{1}{z_0} + α\frac{1}{z_1}}\), where \(α\) is screen space ratio between two end point \(u_0\) and \(u_1\) with linear depth \(z_0\) and \(z_1\). We don’t usually think about fixing perspective UV because modern hardware does all the hard work for us already, however when we need to deal with screen space and view space, this conversion comes in handy.</p>
</div>]]></description><link>https://lxjk.github.io/2017/06/10/Conversion-between-View-Space-Linear-and-Screen-Space-Linear.html</link><guid isPermaLink="true">https://lxjk.github.io/2017/06/10/Conversion-between-View-Space-Linear-and-Screen-Space-Linear.html</guid><category><![CDATA[Math]]></category><category><![CDATA[Graphics]]></category><dc:creator><![CDATA[Eric Zhang]]></dc:creator><pubDate>Sat, 10 Jun 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Calculate Minimal Bounding Sphere of Frustum]]></title><description><![CDATA[<div class="paragraph">
<p>I came across this problem when fixing shadow shimmering in Cascaded Shadow Map, but it could be used in many other cases. To describe what we are going to do more specifically: given a frustum with near plane \(n\), far plane \(f\), and field of view angle \(fov\), we need to calculate the center \(C\) and radius \(R\) of its minimal bounding sphere. In the calculation we will use right hand Y up coordinate system (forward is –Z axis) for 3D, and a similar coordinate system (forward is –Y axis) for 2D. For convenience we denote half FOV angle as \(α=\frac{fov}{2}\).</p>
</div>
<div class="paragraph">
<p>Let’s start with 2D situation. First consider an extreme case as shown in figure 1 (a), if near plane is very closed to far plane, that is \(n=f\). Obviously our minimal bounding sphere sits in the center of far plane, and the radius will be half far plane width:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
C&amp;=(0, -f)\\
R&amp;=f\tanα
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Consider another extreme case as shown in figure 1 (b), if near plane is \(0\), that is \(n=0.\) We are actually calculating the circumscribed circle of an isosceles triangle. The center of our bounding sphere sits on Y axis \(C=(0,-R)\). I’m not going to calculate the radius here, since we don’t need it for the following calculation, but it should be easy to figure out if you are interested.</p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock left">
<div class="content">
<img src="https://github.com/lxjk/lxjk.github.io/raw/master/images/frustum/fig1a.png" alt="fig1a.png" width="300">
</div>
<div class="title">Figure 1 (a)</div>
</div>
<div class="imageblock left">
<div class="content">
<img src="https://github.com/lxjk/lxjk.github.io/raw/master/images/frustum/fig1b.png" alt="fig1b.png" width="300">
</div>
<div class="title">Figure 1 (b)</div>
</div>
</div>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="https://github.com/lxjk/lxjk.github.io/raw/master/images/frustum/fig2.png" alt="fig2.png" width="400">
</div>
<div class="title">Figure 2</div>
</div>
<div class="paragraph">
<p>Now let’s go back to the normal case as shown in figure 2. Intuitively we can guess the minimal bounding sphere should sits on somewhere between near plane center \({N_0}(0,-n)\) and far plane center \({F_0}(0,-f)\), and it should have the same distance to all 4 vertices of the frustum, that is \(\left|\vec{C{N_1}}\right|=\left|\vec{C{N_2}}\right|=\left|\vec{C{F_1}}\right|=\left|\vec{C{F_2}}\right|=R\). Can we actually find such a point? Since frustum is symmetrical along Y axis, if we found a point \(C\) such that \(\left|\vec{C{N_1}}\right|=\left|\vec{C{F_1}}\right|=R\), it is guaranteed we will have \(\left|\vec{C{N_2}}\right|=\left|\vec{C{F_2}}\right|=R\) as well. Now we just need to calculate that point.</p>
</div>
<div class="paragraph">
<p>Remember our half FOV angle is denoted as \(α\), we have \(\left|\vec{{N_0}{N_1}}\right|=n\tan⁡α\), \(\left|\vec{{F_0}{F_1}}\right|=f\tan⁡α\), \(\left|\vec{{N_0}{F_0}}\right|=f-n\). We denote \(x=\left|\vec{C{N_0}}\right|\), then \(\left|\vec{C{F_0}}\right|=f-n-x\), if we solve \(x\) we can find out radius \(R\):</p>
</div>
<div class="stemblock">
<div class="content">
\[\left|\vec{{C}{N_0}}\right|^{2}+\left|\vec{{N_0}{N_1}}\right|^{2}=\left|\vec{{C}{N_1}}\right|^{2}=R^{2}=\left|\vec{{C}{F_1}}\right|^{2}=\left|\vec{{C}{F_0}}\right|^{2}+\left|\vec{{F_0}{F_1}}\right|^{2}\\
\begin{align*}
x^{2}+n^{2}\tan^{2}α&amp;=(f-n-x)^{2}+f^{2}\tan^{2}α\\
x^{2}+n^{2}\tan^{2}α&amp;=(f-n)^{2}-2(f-n)x+x^{2}+f^{2}\tan^{2}α\\
x&amp;=\frac{1}{2}((f-n)+(f+n)\tan^{2}α)\\
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Now we can get the radius:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
R&amp;=\left|\vec{{C}{N_1}}\right|=\sqrt{\left|\vec{{C}{N_0}}\right|^{2}+\left|\vec{{N_0}{N_1}}\right|^{2}}\\
&amp;=\sqrt{x^{2}+n^{2}\tan^{2}α}\\
&amp;=\frac{1}{2}\sqrt{(f-n)^{2}+2(f^{2}+n^{2})\tan^{2}α+(f+n)^{2}\tan^{4}α}
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>And the center will be</p>
</div>
<div class="stemblock">
<div class="content">
\[C=(0,-(n+x))=(0, -\frac{1}{2}(f+n)(1+\tan^{2}α))\]
</div>
</div>
<div class="paragraph">
<p>However there is a catch. As shown in figure 3, if the near plane is close to far plane, we might end up with a bounding sphere larger than we need. Sphere \(C\) is the sphere we calculated, but sphere \(C'={F_0}\) is the minimal sphere. This is because based on our calculation, we want to fit all 4 vertices on the sphere. In the normal case this will give us the minimal sphere, but when near plane is close to far plane, it is better to give up near plane since it is already inside the bounding sphere based on far plane only.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="https://github.com/lxjk/lxjk.github.io/raw/master/images/frustum/fig3.png" alt="fig3.png" width="400">
</div>
<div class="title">Figure 3</div>
</div>
<div class="paragraph">
<p>What is the condition we should give up? Take another look at the sphere center we calculated, we got a larger sphere because our center is farther along Y axis than our far plane, so we can simply make sure our bounding sphere center sits within the frustum, if it is farther than the far plane, clamp it to the far plane. The condition that we should clamp is</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
-\frac{1}{2}(f+n)(1+\tan^{2}α)&amp;\leqslant-f\\
\tan^{2}α&amp;\geqslant\frac{f-n}{f+n}
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>To rewrite our result</p>
</div>
<div class="paragraph">
<p>If \(\tan^{2}α\geqslant\frac{f-n}{f+n}\)</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
C&amp;=(0, -f)\\
R&amp;=f\tanα
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Else</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
C&amp;=(0, -\frac{1}{2}(f+n)(1+\tan^{2}α))\\
R&amp;=\frac{1}{2}\sqrt{(f-n)^{2}+2(f^{2}+n^{2})\tan^{2}α+(f+n)^{2}\tan^{4}α}
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>We solved 2D situation, going into 3D it is actually no more difficult than 2D. As shown in figure 4, we just need to work on the 2D frustum defined by \({N_1}{N_3}{F_1}{F_3}\). Similarly, based on symmetricity of frustum, if we find a bonding sphere that \(N_1\) and \(F_1\) is on the sphere, it is guaranteed that all 8 vertices of frustum will be on the sphere. The only extra thing we need to do here is calculate \(\left|\vec{{N_0}{N_1}}\right|\) and \(\left|\vec{{F_0}{F_1}}\right|\). It depends on which is the major axis of your field of view. I will use X axis as major axis for example, let \(w\) be viewport width, \(h\) be viewport height, we have \({N_1}=(-n\tan⁡α,n\frac{h}{w}\tan⁡α)\), \(\left|\vec{{N_0}{N_1}}\right|=n\sqrt{1+\frac{h^{2}}{w^{2}}}\tan⁡α\), similarly \(\left|\vec{{F_0}{F_1}}\right|=f\sqrt{1+\frac{h^{2}}{w^{2}}}\tan⁡α\).</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="https://github.com/lxjk/lxjk.github.io/raw/master/images/frustum/fig4.png" alt="fig4.png" width="500">
</div>
<div class="title">Figure 4</div>
</div>
<div class="paragraph">
<p>Here is our collusion. For 3D frustum with viewport width \(w\), height \(h\), near plane \(n\), far plane \(f\), X axis field of view angle \(fov\), let \(k=\sqrt{1+\frac{h^{2}}{w^{2}}}\tan⁡{\frac{fov}{2}}\), then the minimal bounding sphere is:</p>
</div>
<div class="paragraph">
<p>If \(k^{2}\geqslant\frac{f-n}{f+n}\)</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
C&amp;=(0,0,-f)\\
R&amp;=fk
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Else</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
C&amp;=(0,0,-\frac{1}{2}(f+n)(1+k^{2}))\\
R&amp;=\frac{1}{2}\sqrt{(f-n)^{2}+2(f^{2}+n^{2})k^{2}+(f+n)^{2}k^{4}}
\end{align*}\]
</div>
</div>]]></description><link>https://lxjk.github.io/2017/04/15/Calculate-Minimal-Bounding-Sphere-of-Frustum.html</link><guid isPermaLink="true">https://lxjk.github.io/2017/04/15/Calculate-Minimal-Bounding-Sphere-of-Frustum.html</guid><category><![CDATA[Math]]></category><category><![CDATA[Graphics]]></category><dc:creator><![CDATA[Eric Zhang]]></dc:creator><pubDate>Sat, 15 Apr 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[A Different Way to Understand Quaternion and Rotation]]></title><description><![CDATA[<div class="sect2">
<h3 id="_before_we_start">Before We Start</h3>
<div class="paragraph">
<p>Quaternion is widely used in game engines to represent 3D rotation. As a game engineer you might be using quaternion explicitly or implicitly in your daily work, but do you really understand what is going on under the hood when you are calling “rotate a vector” or “combine two rotations”? Why rotating a vector \(\vec{v}\) by quaternion \(q\) is calculated by a “sandwich” multiplication: \(q\vec{v}q^{-1}\) ? Why rotating by quaternion \(q_1\) then \(q_2\) is in the reversed order: \({q_2}{q_1}\), and can you visualize the result rotation axis and angle?</p>
</div>
<div class="paragraph">
<p>Understanding quaternions also leads to more efficient use of quaternion. For example, one common situation in game development is that we need an object to face its opposite direction. What we usually would do is to get the normal or forward vector, negate it, build a rotation out of it, and assign the rotation to the object. Later in this article we will see how much calculation we need to do in this process. However with the understanding of quaternion, we only need to do \(q=(q.y,-q.x,q.w,-q.z)\), and I will show you why.</p>
</div>
<div class="paragraph">
<p>In this article, I will try to avoid touching the algebra structure of quaternion, or having to imagine a 4 dimensional hyper sphere. I will start with a special rotation operation: flip, and use that to visualize quaternion in a more accessible and geometrical way. This article will be split into 2 parts. In Part 1 we will talk about the idea of quaternion, understand and visualize how it rotates a vector and how to compose rotations. In Part 2 we will talk about how to make use of our understanding in Part 1, and how it is used in game engine versus rotation matrix and Euler angles.</p>
</div>
<div class="paragraph">
<p>I would assume you are comfortable with 3D math (vector dot product and cross product) and basic trigonometry.</p>
</div>
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel2">
<li><a href="#_before_we_start">Before We Start</a></li>
<li><a href="#_part_1_theory">Part 1. Theory</a>
<ul class="sectlevel2">
<li><a href="#_quaternion_definition">Quaternion Definition</a></li>
<li><a href="#_rotation_and_flip">Rotation and Flip</a></li>
<li><a href="#_quaternion_and_flip">Quaternion and Flip</a></li>
<li><a href="#_flip_composition">Flip Composition</a></li>
<li><a href="#_flip_vector">Flip Vector</a></li>
<li><a href="#_rotate_vector">Rotate Vector</a></li>
<li><a href="#_rotation_composition">Rotation Composition</a></li>
<li><a href="#_summary_of_part_1">Summary of Part 1</a></li>
</ul>
</li>
<li><a href="#_part_2_application">Part 2. Application</a>
<ul class="sectlevel2">
<li><a href="#_calculation_of_vector_rotation">Calculation of Vector Rotation</a></li>
<li><a href="#_world_rotation_and_local_rotation">World Rotation and Local Rotation</a></li>
<li><a href="#_rotation_along_x_y_z_axis">Rotation along X/Y/Z Axis</a></li>
<li><a href="#_euler_angles_to_quaternion">Euler Angles to Quaternion</a></li>
<li><a href="#_quaternion_and_rotation_matrix">Quaternion and Rotation Matrix</a></li>
<li><a href="#_quaternion_to_euler_angles">Quaternion to Euler Angles</a></li>
<li><a href="#_summary_of_part_2">Summary of Part 2</a></li>
</ul>
</li>
<li><a href="#_appendix">Appendix</a>
<ul class="sectlevel2">
<li><a href="#_derive_quaternion_multiplication">Derive Quaternion Multiplication</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="sect1">
<h2 id="_part_1_theory">Part 1. Theory</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_quaternion_definition">Quaternion Definition</h3>
<div class="paragraph">
<p>Quaternion is a 4-tuple denoted as \(q=(x,y,z,w)\). The length of a quaternion is defined as \(\left|q\right| =\sqrt{x^{2}+y^{2}+z^{2}+w^{2}}\), just as you would expected from a 4D vector.</p>
</div>
<div class="paragraph">
<p>In order to represent 3D rotation, we have a constraint on the quaternions we use. But before that I want to introduce Euler’s rotation theorem:</p>
</div>
<div class="paragraph">
<p><strong><em>Any rotation in 3D space is equivalent to a single rotation of angle \(θ\) along some axis \(\vec{v}\).</em></strong></p>
</div>
<div class="paragraph">
<p>We can use quaternion to describe this angle-axis rotation : \(q=(\sin⁡\frac{θ}{2}\vec{v}.x,\sin⁡\frac{θ}{2}\vec{v}.y,\sin⁡\frac{θ}{2}\vec{v}.z,\cos⁡\frac{θ}{2})\), or in a more compact form \(q=(\sin⁡\frac{θ}{2}\vec{v},\cos⁡\frac{θ}{2})\). We call this form the vector form of a quaternion, and we will use this form throughout this article. You might be thinking why we are using \(\frac{θ}{2}\) other than using \(θ\) directly. I will explain that in a later section.</p>
</div>
<div class="paragraph">
<p>It is easy to see the length of this quaternion \(\left|q\right|=\sqrt{\sin^{2}\frac{θ}{2}\left|\vec{v}\right|^{2}+\cos^{2}\frac{θ}{2}}=1\). (Remember the axis \(\vec{v}\) is a unit vector that \(\left|\vec{v}\right|=1\)). We call it a unit quaternion if the length \(\left|q\right|=1\). So we can rewrite Euler’s rotation theorem in quaternion term:</p>
</div>
<div class="paragraph">
<p><strong><em>Any 3D rotation is equivalent a unit quaternion \(q\) that \(\left|q\right|=1\).</em></strong></p>
</div>
<hr>
<div class="sidebarblock">
<div class="content">
<div class="title">Side Note</div>
<div class="paragraph">
<p>This claim actually has 2 sides. Let me go a little be more in details in math term:
(1). For any 3D rotation equivalent to a rotation angle \(θ\) along axis \(\vec{v}\), there exists a unit quaternion \(q=(\sin⁡\frac{θ}{2}\vec{v},\cos⁡\frac{θ}{2})\) to describe this rotation.
(2). For any unit quaternion \(q=(x,y,z,w)\), it describes a rotation of angle \(θ=2\cos^{-1}w\) along axis \(\vec{v}=\frac{1}{\sqrt{1-w^{2}}}(x,y,z)\).</p>
</div>
</div>
</div>
<hr>
<div class="paragraph">
<p>From now on, any quaternion \(q\) used in this article is by default a unit quaternion, and we will use \(q\) to describe rotations.</p>
</div>
</div>
<div class="sect2">
<h3 id="_rotation_and_flip">Rotation and Flip</h3>
<div class="paragraph">
<p>Now let’s forget quaternion for a minute, and focus on the nature of rotations. This part is the key to understand quaternion calculation in an easier way.</p>
</div>
<div class="paragraph">
<p><strong><em>Any 3D rotation can be composed by 2 flips along some axes.</em></strong></p>
</div>
<div class="paragraph">
<p>The reason we want to break down a rotation into flips, is that flips are much easier to think and calculate than general 3D rotation. We will start from flip and build our way to understand rotation.
Here is a loose proof of this idea. We define counter-clockwise as the positive direction of rotation. First consider a special case. We have a rotation \(q\), which rotates  \(+90^{\circ}\) along axis Z. Now I can say this rotation is the same as 2 flips along axis \(\vec{a}\) and \(\vec{b}\), both of them are on XY plane, and the angle from \(\vec{a}\) to \(\vec{b}\) is \(+45^{\circ}\).</p>
</div>
<div class="imageblock" style="text-align: center;float: right">
<div class="content">
<img src="https://github.com/lxjk/lxjk.github.io/raw/master/images/quaternions/fig1_b.png" alt="fig1 b.png" width="300">
</div>
<div class="title">Figure 1 (b)</div>
</div>
<div class="imageblock" style="text-align: center;float: right">
<div class="content">
<img src="https://github.com/lxjk/lxjk.github.io/raw/master/images/quaternions/fig1.png" alt="fig1.png" width="300">
</div>
<div class="title">Figure 1 (a)</div>
</div>
<div class="paragraph">
<p>We demonstrate this through Figure 1. For any vector \(\vec{v}\), the result of this rotation is \(\vec{v''}\) , which is the same as flip \(\vec{v}\) along axis \(\vec{a}\) and get \(\vec{v'}\), and then flip \(\vec{v'}\) along axis \(\vec{b}\) and get \(\vec{v''}\).</p>
</div>
<div class="paragraph">
<p>It doesn’t matter where \(\vec{a}\) and \(\vec{b}\) are on the XY plane, but the order must be kept. If we choose \(\vec{b}\) by rotating \(\vec{a}\) along axis Z by \(+45^{\circ}\) with the positive direction we defined above, then we must flip along \(\vec{a}\) first then along \(\vec{b}\) to get our target rotation. The order and the sign of angle is important, as you can easily see flip along \(\vec{b}\) first then along \(\vec{a}\) will give a different result.</p>
</div>
<div class="paragraph">
<p>It’s not hard to generalize to a rotation of any angle \(θ\) along Z axis. And in this case, the angle from \(\vec{a}\) to \(\vec{b}\) is \(\frac{θ}{2}\).</p>
</div>
<div class="paragraph">
<p>What if the axis is not Z axis but any unit vector \(\vec{u}\) ? It turns out to be very straight forward. \(\vec{a}\) and \(\vec{b}\) are no longer on XY plane but on a plane cross the origin and perpendicular to \(\vec{u}\), as in Figure 2.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="https://github.com/lxjk/lxjk.github.io/raw/master/images/quaternions/fig2.png" alt="fig2.png" width="400">
</div>
<div class="title">Figure 2</div>
</div>
<div class="paragraph">
<p>Now we can rewrite our flip composition rule in a more specific form:</p>
</div>
<div class="paragraph">
<p><strong><em>Any 3D rotation equivalent to rotating angle \(θ\) along axis \(\vec{v}\) can be represented as a sequence of 2 flips along axis \(\vec{a}\) and \(\vec{b}\), such that \(\vec{a}·\vec{v}=0\), \(\vec{b}·\vec{v}=0\) and the angle from \(\vec{a}\) to \(\vec{b}\): \(&lt;\vec{a},\vec{b}&gt;=\frac{θ}{2}\).</em></strong></p>
</div>
<div class="paragraph">
<p>This representation means if we fully understand flip, which is easier to visualize, we can fully understand rotation and quaternions, since any quaternion can be broken down to flips.</p>
</div>
</div>
<div class="sect2">
<h3 id="_quaternion_and_flip">Quaternion and Flip</h3>
<div class="paragraph">
<p>Now let’s recall the quaternion vector form \(q=(\sin⁡\frac{θ}{2}\vec{v},\cos⁡\frac{θ}{2})\). With the discussion of flips above, you can almost immediately see why we are using \(\frac{θ}{2}\) here.</p>
</div>
<div class="paragraph">
<p>Think about flips again. A flip along axis \(\vec{a}\) is also a \(180^{\circ}\) rotation along axis \(\vec{a}\). So this flip can be represented in quaternion term</p>
</div>
<div class="stemblock">
<div class="content">
\[q_a=(\sin⁡\frac{180^{\circ}}{2}\vec{a},\cos⁡\frac{180^{\circ}}{2})=(\vec{a},0)\]
</div>
</div>
<div class="paragraph">
<p>From now on we will use quaternion to represent flip. Actually any unit quaternion with \(q.w=0\) is a flip along axis \((q.x,q.y,q.z)\).</p>
</div>
</div>
<div class="sect2">
<h3 id="_flip_composition">Flip Composition</h3>
<div class="paragraph">
<p>Here we need to introduce the multiplication of general quaternion. Let \(q_1=(\vec{v_1},w_1)\), \(q_2=(\vec{v_2},w_2)\) then</p>
</div>
<div class="stemblock">
<div class="content">
\[{q_1}{q_2}=(\vec{v_1},w_1)(\vec{v_2},w_2)=(w_1\vec{v_2} + w_2\vec{v_1} + \vec{v_1}×\vec{v_2}, {w_1}{w_2}-\vec{v_1}·\vec{v_2})\]
</div>
</div>
<div class="paragraph">
<p>Note here \(q_1\) and \(q_2\) are not necessarily unit quaternion, so even I’m using vector form, there’s no need to put \(\sin⁡\frac{θ}{2}\) and \(\cos⁡\frac{θ}{2}\) as we did for unit quaternions. It’s hard to explain this definition without introducing the algebra structure of quaternions, so I will skip that. If you are interesting to know how this is derived, quaternion <a href="https://en.wikipedia.org/wiki/Quaternion#Definition">Wiki page</a> has a very straight forward introduction.</p>
</div>
<div class="paragraph">
<p>We are not going to use this general quaternion multiplication in Part 1. Here we only need to know a simpler form, the multiplication of flips. Let \(q_a=(\vec{a},0)\), \(q_b=(\vec{b},0)\) then</p>
</div>
<div class="stemblock">
<div class="content">
\[{q_a}{q_b}=(\vec{a},0)(\vec{b},0)=(\vec{a}×\vec{b},-\vec{a}·\vec{b})\]
</div>
</div>
<div class="paragraph">
<p>It is naturally derived from the general form, and we will be only using this multiplication in Part 1.</p>
</div>
<div class="paragraph">
<p>With flip multiplication defined, we can rewrite our flip composition rule again:</p>
</div>
<div class="paragraph">
<p><strong><em>Any 3D rotation \(q=(\sin⁡\frac{θ}{2}\vec{v},\cos⁡\frac{θ}{2})\) can be represented as a sequence of 2 flips \(q_a=(\vec{a},0)\) and \(q_b=(\vec{b},0)\), such that</em></strong></p>
</div>
<div class="stemblock">
<div class="content">
\[q=-{q_b}{q_a}\]
</div>
</div>
<div class="paragraph">
<p><strong><em>where \(\vec{a}·\vec{v}=0\), \(\vec{b}·\vec{v}=0\) and the angle from \(\vec{a}\) to \(\vec{b}\): \(&lt;\vec{a},\vec{b}&gt;=\frac{θ}{2}\).</em></strong></p>
</div>
<div class="paragraph">
<p>You might be thinking why it is not \(q= {q_a}{q_b}\) instead. We will show where the order and the negative sign coming from in the proof.</p>
</div>
<div class="paragraph">
<p>\(\vec{a}·\vec{b}=\cos&lt;\vec{a},\vec{b}&gt;\left|\vec{a}\right|\left|\vec{b}\right|=\cos\frac{θ}{2}\). Since \(\vec{a}·\vec{v}=0\), \(\vec{b}·\vec{v}=0\) and \(\left|\vec{v}\right|=1\), we have \(\vec{a}×\vec{b}=\sin&lt;\vec{a},\vec{b}&gt;\left|\vec{a}\right|\left|\vec{b}\right|\vec{v}=\sin\frac{θ}{2}\vec{v}\).</p>
</div>
<div class="paragraph">
<p>If you are not sure about the direction of the cross product, see Figure 2.</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
q&amp;=(\sin⁡\frac{θ}{2}\vec{v},\cos⁡\frac{θ}{2})\\
&amp;=(\vec{a}×\vec{b},\vec{a}·\vec{b})\\
&amp;=-(-\vec{a}×\vec{b},-\vec{a}·\vec{b})\\
&amp;=(\vec{b}×\vec{a},-\vec{a}·\vec{b})\\
&amp;=-{q_b}{q_a}
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Here you can also clearly see why we are using \(\sin⁡\frac{θ}{2}\) and \(\cos⁡\frac{θ}{2}\) in quaternions.</p>
</div>
<div class="paragraph">
<p>One thing I need to mention here is the negation of a quaternion. \(q=(\sin⁡\frac{θ}{2}\vec{v},\cos⁡\frac{θ}{2})\), then</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
{-q}&amp;=(-\sin⁡\frac{θ}{2}\vec{v},-\cos⁡\frac{θ}{2})\\
&amp;=(-\sin⁡\frac{2π-θ}{2}\vec{v},\cos⁡\frac{2π-θ}{2})\\
&amp;=(\sin⁡\frac{-(2π-θ)}{2}\vec{v},\cos⁡\frac{-(2π-θ)}{2})\\
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Recall that \(\sin⁡θ=\sin(π-θ)\) and \(-\cos⁡θ=\cos(π-θ)\), then \(-\sin⁡θ=\sin(-θ)\) and \(\cos⁡θ=\cos(-θ)\).</p>
</div>
<div class="paragraph">
<p>It shows that \(-q\) is a rotation along axis \(\vec{v}\) of angle \(-(2π-θ)\), which is exactly the same rotation as \(q\). For example if \(θ=90^{\circ}\) then \(-(2π-θ)=-270^{\circ}\), rotate \(90^{\circ}\) along axis \(\vec{v}\) is the same as rotate \(270^{\circ}\) degree but in the opposite direction along the same axis \(\vec{v}\).</p>
</div>
<div class="paragraph">
<p>The fact that \(q\) and \(–q\) represents the same rotation is usually called double-cover. However in our calculation I don’t want you to simply think \(q\) and \(–q\) are the same. They are different in quaternion space, even though they map to the same 3D rotation. The negative sign of the flip composition needs to be there.</p>
</div>
<div class="paragraph">
<p>The order of \(q=-{q_b}{q_a}\) on the right hand side is important. It means flip along \(\vec{a}\) first and then \(\vec{b}\). Actually all unit quaternion multiplication needs to be “read” from right to left when we are thinking about the order of applying those rotations.</p>
</div>
<hr>
<div class="sidebarblock">
<div class="content">
<div class="title">Side Note</div>
<div class="paragraph">
<p>We can however get rid of the negative sign by choosing \(\vec{a}\) and \(\vec{b}\) differently.</p>
</div>
<div class="paragraph">
<p><em>Any 3D rotation \(q=(\sin⁡\frac{θ}{2}\vec{v},\cos⁡\frac{θ}{2})\) can be represented as a sequence of 2 flips \(q_a=(\vec{a},0)\) and \(q_b=(\vec{b},0)\), such that
\(q={q_b}{q_a}\)
where \(\vec{a}·\vec{v}=0\), \(\vec{b}·\vec{v}=0\) and the angle from \(\vec{a}\) to \(\vec{b}\): \(&lt;\vec{a},\vec{b}&gt;=\frac{θ}{2}-π\).</em></p>
</div>
<div class="paragraph">
<p>It becomes harder to visualize \(\vec{a}\) and \(\vec{b}\) if we go this way, and the negative sign does not really introduce a lot of difficulties, so we will stick with that negative sign in this article.</p>
</div>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_flip_vector">Flip Vector</h3>
<div class="paragraph">
<p>Given a flip \(q_a=(\vec{a},0)\) and vector \(\vec{v}\), we are ready to calculate the result of the flip \(\vec{v'}\).</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="https://github.com/lxjk/lxjk.github.io/raw/master/images/quaternions/fig3.png" alt="fig3.png" width="400">
</div>
<div class="title">Figure 3</div>
</div>
<div class="paragraph">
<p>According to flip definition, \(\vec{v}\), \(\vec{a}\) and \(\vec{v'}\) are on the same plane, and the angle \(&lt;\vec{v},\vec{a}&gt;=&lt;\vec{a},\vec{v'}&gt;\).</p>
</div>
<div class="paragraph">
<p>If we treat \(\vec{v}\) and \(\vec{v'}\) as the axis of flip \(q_v=(\vec{v},0)\) and \(q_v'=(\vec{v'},0)\). From our flip composition rule, flipping along axis \(\vec{v}\) then \(\vec{a}\) should give us the same rotation as flipping along axis \(\vec{a}\) then \(\vec{v'}\).</p>
</div>
<div class="paragraph">
<p>We can actually calculate the result rotation. Let \(&lt;\vec{v},\vec{a}&gt;=&lt;\vec{a},\vec{v'}&gt;=\frac{θ}{2}\), \(\vec{u}=\frac{\vec{v}×\vec{a}}{\left|\vec{v}×\vec{a}\right|}=\frac{\vec{a}×\vec{v'}}{\left|\vec{a}×\vec{v'}\right|}\). Then the result rotation is of angle \(θ\) along axis \(\vec{u}\).</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
q&amp;=(\sin⁡\frac{θ}{2}\vec{v},\cos⁡\frac{θ}{2})\\
&amp;=-{q_a}{q_v}\\
&amp;=-{q_v'}{q_a}
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>This gives \({q_v'}{q_a}={q_a}{q_v}\).</p>
</div>
<div class="paragraph">
<p>(Here \(\left|\vec{v}×\vec{a}\right|=\left|\vec{a}×\vec{v'}\right|=\sin\frac{θ}{2}\).If you are not sure what’s going on here, go back <a href="#_flip_composition">Flip Composition</a> and read the proof)</p>
</div>
<div class="paragraph">
<p>Now we need to introduce the inverse of a quaternion. The inverse of \(q\) is denoted as \(q^{-1}\), such that \(qq^{-1}=q^{-1}q=(\vec{0},1)\).</p>
</div>
<div class="paragraph">
<p>\(I=(\vec{0},1)\) is called identity quaternion, means no rotation at all. You can think of \(I=(\sin⁡0\vec{v},\cos⁡0)\), which means rotating \(0^{\circ}\) along any axis \(\vec{v}\). We haven’t gone into quaternion multiplication or rotation composition, but it’s not hard to see for any quaternion \(q\), \(qI=Iq=q\).</p>
</div>
<div class="paragraph">
<p>In the case of unit quaternion, the idea of inversed quaternion is if you apply a rotation, then apply its inverse, the result should be no rotation at all. And it is the same if you apply an inversed rotation then apply the original one.</p>
</div>
<div class="paragraph">
<p>For any unit quaternion \(q=(\sin⁡\frac{θ}{2}\vec{v},\cos⁡\frac{θ}{2})\), then \(q^{-1}=(-\sin⁡\frac{θ}{2}\vec{v},\cos⁡\frac{θ}{2})\). You can understand this in two ways, either \(q^{-1}=(\sin⁡\frac{θ}{2}(-\vec{v}),\cos⁡\frac{θ}{2})\) or \(q^{-1}=(\sin⁡\frac{-θ}{2}\vec{v},\cos⁡\frac{-θ}{2})\). \(q^{-1}\) is either a rotation of angle \(θ\) along axis \(-\vec{v}\), or a rotation of angle \(–θ\) along axis \(\vec{v}\). Either way it will cancel out the original rotation.</p>
</div>
<div class="paragraph">
<p>I will give a quick proof in the case of flip. You can try extend this proof to general unit quaternion. If \(q_a=(\vec{a},0)\), \(q_a^{-1}=(-\vec{a},0)\), we have</p>
</div>
<div class="stemblock">
<div class="content">
\[{q_a}{q_a^{-1}}=(\vec{a}×-\vec{a},-(\vec{a}·-\vec{a}))=(\vec{0},1)\]
</div>
</div>
<div class="paragraph">
<p>(Make sure you understand the difference between \(q^{-1}\) and \(–q\). Read <a href="#_flip_composition">Flip Composition</a> about quaternion negation if you are not sure.)</p>
</div>
<div class="paragraph">
<p>We can go back to previous result of flipping vector \({q_v'}{q_a}={q_a}{q_v}\). Apply inverse flip of \(q_a\) on both side, the equation becomes</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
{q_v'}{q_a}{q_a^{-1}}&amp;={q_a}{q_v}{q_a^{-1}}\\
q_v'&amp;={q_a}{q_v}{q_a^{-1}}
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>This provides us a way to calculate the result of flip. Since we only need the vector part of the result, we can denote this as</p>
</div>
<div class="stemblock">
<div class="content">
\[\vec{v'}={q_a}\vec{v}{q_a^{-1}}\]
</div>
</div>
<div class="paragraph">
<p>When we put a vector \(\vec{v}\) in quaternion multiplication, we are implicitly making that vector the axis of a flip to stuff it into a quaternion \((\vec{v},0)\). This is how the “sandwich” multiplication form comes from, but only in the form of flip. We will prove that our result holds the same for any rotation in the next section.</p>
</div>
</div>
<div class="sect2">
<h3 id="_rotate_vector">Rotate Vector</h3>
<div class="paragraph">
<p>We know any 3D rotation \(q\) can be broken down into 2 flips \(q= -{q_b}{q_a}\), which means flipping along \(\vec{a}\) first and then \(\vec{b}\). So for a vector \(\vec{v}\), we apply the first flip and get</p>
</div>
<div class="stemblock">
<div class="content">
\[\vec{v'}={q_a}\vec{v}{q_a^{-1}}\]
</div>
</div>
<div class="paragraph">
<p>Then we apply the second flip \(\vec{v'}\) and get</p>
</div>
<div class="stemblock">
<div class="content">
\[\vec{v''}={q_b}\vec{v'}{q_b^{-1}}\]
</div>
</div>
<div class="paragraph">
<p>So the final result is</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
\vec{v''}&amp;={q_b}{q_a}\vec{v}{q_a^{-1}}{q_b^{-1}}\\
&amp;=({q_b}{q_a})\vec{v}({q_b}{q_a})^{-1}\\
&amp;=(-q)\vec{v}(-q^{-1})\\
&amp;=q\vec{v}q^{-1}\\
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Here you can see why \(q= -{q_b}{q_a}\) needs to be in this order.</p>
</div>
<div class="paragraph">
<p>One thing we need to prove</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
{q_a^{-1}}{q_b^{-1}}&amp;=(-\vec{a},0)(-\vec{b},0)\\
&amp;=(-\vec{a}×-\vec{b},-(-\vec{a})·(-\vec{b}))\\
&amp;=(\vec{a}×\vec{b},-\vec{a}·\vec{b})\\
&amp;=(-\vec{b}×\vec{a},-\vec{b}·\vec{a})\\
&amp;=({q_b}{q_a})^{-1}
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>At this point, we fully explained how to rotate a vector using quaternion.</p>
</div>
</div>
<div class="sect2">
<h3 id="_rotation_composition">Rotation Composition</h3>
<div class="paragraph">
<p>Given rotation \(q_1\) and \(q_2\), from the formula in the previous section, if we rotate vector \(\vec{v}\) by \(q_1\) first then by \(q_2\), we have</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
\vec{v'}&amp;={q_1}\vec{v}{q_1^{-1}}\\
\vec{v''}&amp;={q_2}\vec{v'}{q_2^{-1}}\\
&amp;={q_2}{q_1}\vec{v}{q_1^{-1}}{q_2^{-1}}\\
&amp;=({q_2}{q_1})\vec{v}({q_2}{q_1})^{-1}\\
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>It is the same as apply the combined rotation \(q={q_2}{q_1}\). Be careful about the multiplication order.</p>
</div>
<div class="paragraph">
<p>Again we need to prove \({q_1^{-1}}{q_2^{-1}}=({q_2}{q_1})^{-1}\), but we will do this later. This equation is actually very easy to understand in geometric term. We have a combined rotation \(q={q_2}{q_1}\) that rotates \(q_1\) first then rotates \(q_2\). If we want to undo this rotation, which means apply the inverse \(q^{-1}=({q_2}{q_1})^{-1}\), we need to undo \(q_2\) first then undo \(q_1\), that is effectively \(q_1^{-1}q_2^{-1}\).</p>
</div>
<div class="paragraph">
<p>What does it really mean to combine 2 rotations, can we visualize the rotation axis and angle of the result? By converting rotations to flips we actually do that.</p>
</div>
<div class="paragraph">
<p>Let \(q_1=(\sin⁡\frac{θ_1}{2}\vec{v_1},\cos⁡\frac{θ_1}{2})\), \(q_2=(\sin⁡\frac{θ_2}{2}\vec{v_2},\cos⁡\frac{θ_2}{2})\), we need to choose a special flip break down, such that they share one flip: \(q_1=-{q_c}{q_a}\), \(q_2=-{q_b}{q_c}\).</p>
</div>
<div class="paragraph">
<p>Can we find such a break down? Remember the rule of flip composition requires the flip axis to be perpendicular to the rotation axis, that is \(\vec{c}·\vec{v_1}=0\), \(\vec{c}·\vec{v_2}=0\), we can choose \(\vec{c}=\frac{\vec{v_1}×\vec{v_2}}{\left|\vec{v_1}×\vec{v_2}\right|}\).</p>
</div>
<div class="paragraph">
<p>Based on \(\vec{c}\) we can find out the other two axes: rotate \(\vec{c}\) along axis \(\vec{v_1}\) by angle \(-\frac{θ_1}{2}\) results in \(\vec{a}\); rotate \(\vec{c}\) along axis \(\vec{v_2}\) by angle \(\frac{θ_2}{2}\) results in \(\vec{b}\). This process is demonstrated in Figure 4.</p>
</div>
<div class="paragraph">
<p>Now we have \(\vec{a}·\vec{v_1}=0\), \(\vec{c}·\vec{v_1}=0\), \(&lt;\vec{a},\vec{c}&gt;=\frac{θ_1}{2}\) and \(\vec{c}·\vec{v_2}=0\), \(\vec{b}·\vec{v_2}=0\), \(&lt;\vec{c},\vec{b}&gt;=\frac{θ_2}{2}\). Our break down \(q_1=-{q_c}{q_a}\), \(q_2=-{q_b}{q_c}\) is valid. The combined rotation can be written as</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
q&amp;={q_2}{q_1}\\
&amp;=(-{q_b}{q_c})(-{q_c}{q_a})\\
&amp;={q_b}({q_c}{q_c}){q_a}\\
&amp;=-{q_b}{q_a}\\
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Here we need to prove this</p>
</div>
<div class="stemblock">
<div class="content">
\[{q_c}{q_c}=(\vec{c},0)(\vec{c},0)=(\vec{c}×\vec{c},-(\vec{c}·\vec{c}))=(\vec{0},-1)=-I\]
</div>
</div>
<div class="paragraph">
<p>It shows that the combined rotation can be composed by flip \(q_a\) and \(q_b\), which tells the combined rotation is a rotation of angle \(2&lt;\vec{a},\vec{b}&gt;\) along axis \(\vec{u}=\frac{\vec{a}×\vec{b}}{\left|\vec{a}×\vec{b}\right|}\).</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="https://github.com/lxjk/lxjk.github.io/raw/master/images/quaternions/fig4.png" alt="fig4.png" width="400">
</div>
<div class="title">Figure 4</div>
</div>
<div class="paragraph">
<p>In Figure 4, Blue plane is based on \(\vec{v_1}\) and \(\vec{v_1}\), \(\vec{c}\) is perpendicular to that plane.
Orange plane is based on \(\vec{a}\) and \(\vec{b}\), the result rotation axis \(\vec{u}\) is perpendicular to that plane.</p>
</div>
<div class="paragraph">
<p>With the same method, let’s prove the thing we left out:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
{q_1^{-1}}{q_2^{-1}}&amp;=(-{q_c}{q_a})^{-1}(-{q_b}{q_c})^{-1}\\
&amp;={q_a^{-1}}{q_c^{-1}}{q_c^{-1}}{q_b^{-1}}\\
&amp;=-{q_a^{-1}}{q_b^{-1}}\\
&amp;=(-{q_b}{q_a})^{-1}\\
&amp;=({q_b}{q_c}{q_c}{q_a})^{-1}\\
&amp;=({q_2}{q_1})^{-1}\\
\end{align*}\]
</div>
</div>
</div>
<div class="sect2">
<h3 id="_summary_of_part_1">Summary of Part 1</h3>
<div class="paragraph">
<p>In Part 1, we covered the definition of quaternion \(q=(x,y,z,w)\), the vector form of quaternion \(q=(\vec{v},w)\), unit quaternion \(q=(\sin⁡\frac{θ}{2}\vec{v},\cos⁡\frac{θ}{2})\) and how it is used to represent a rotation.</p>
</div>
<div class="paragraph">
<p>We also talked about negation of quaternion \(–q\), and its double cover property; the inverse of quaternion \(q^{-1}\) and identity quaternion \(I=(\vec{0},1)\).</p>
</div>
<div class="paragraph">
<p>We use quaternion to represent flip \(q_a=(\vec{a},0)\), and derive the rule of flip composition \(q=-{q_b}{q_a}\). Based on this rule, we visualized and proved how quaternion rotates a vector by \(\vec{v'}=q\vec{v}q^{-1}\) and how rotation gets composed by \(q={q_2}{q_1}\).</p>
</div>
<div class="paragraph">
<p>We slightly touched quaternion multiplication, and we proved an important equation \({q_1^{-1}}{q_2^{-1}}=({q_2}{q_1})^{-1}\).</p>
</div>
<div class="paragraph">
<p>Hopefully you have a clear idea to think in quaternions now before we head to the application part. Although I’m not going to discuss quaternion’s algebra structure, it definitely helps deepening your understanding. If you are interested to know, quaternion <a href="https://en.wikipedia.org/wiki/Quaternion#Definition">Wiki page</a> is a good resource.</p>
</div>
<div class="paragraph">
<p>It also provides a good way to visualize a quaternion in 4D <a href="https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Quaternion_rotation_operations">here</a>. Our idea of breaking down rotations into 2 flips essentially means all quaternions in 4D space can be generated by elements in it’s largest 3D sub-space  \(\left\{q.w=0\right\}\), and all elements in this sub-space are flips.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_part_2_application">Part 2. Application</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In Part 2 we will be talking about using quaternion to solve real problems in programming. I will be using general vector form \(q=(\vec{v},w)\) even for unit quaternion instead of \(q=(\sin⁡\frac{θ}{2}\vec{v},\cos⁡\frac{θ}{2})\), since it is closed to the actual data format.</p>
</div>
<div class="paragraph">
<p>Recall the definition of general quaternion multiplication we mentioned in Part 1. Let \(q_1=(\vec{v_1},w_1)\), \(q_2=(\vec{v_2},w_2)\) then</p>
</div>
<div class="stemblock">
<div class="content">
\[{q_1}{q_2}=(\vec{v_1},w_1)(\vec{v_2},w_2)=(w_1\vec{v_2} + w_2\vec{v_1} + \vec{v_1}×\vec{v_2}, {w_1}{w_2}-\vec{v_1}·\vec{v_2})\]
</div>
</div>
<div class="paragraph">
<p>We will be using this a lot in the following sections.</p>
</div>
<div class="paragraph">
<p>The coordinate system we use is Z up and right-handed.</p>
</div>
<div class="sect2">
<h3 id="_calculation_of_vector_rotation">Calculation of Vector Rotation</h3>
<div class="paragraph">
<p>In this section we will derive the formula which most game engine are using to rotate a vector with quaternion. Given a rotation \(q=(\vec{v},w)\) and vector \(\vec{p}\), the rotation result is</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
\vec{p'}&amp;=q\vec{p}q^{-1}\\
&amp;=(\vec{v},w)(\vec{p},0)(-\vec{v},w)\\
&amp;=(w\vec{p}+\vec{v}×\vec{p},-\vec{v}·\vec{p})(-\vec{v},w)\\
&amp;=((\vec{v}·\vec{p})\vec{v}+w^{2}\vec{p}+2w(\vec{v}×\vec{p})+\vec{v}×(\vec{v}×\vec{p}),0)\\
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Since we only want the vector part</p>
</div>
<div class="stemblock">
<div class="content">
\[\vec{p'}=(\vec{v}·\vec{p})\vec{v}+w^{2}\vec{p}+2w(\vec{v}×\vec{p})+\vec{v}×(\vec{v}×\vec{p})\]
</div>
</div>
<div class="paragraph">
<p>Here we need to use the following equation of cross product to simplify the result</p>
</div>
<div class="stemblock">
<div class="content">
\[\vec{a}×(\vec{b}×\vec{c})=(\vec{a}·\vec{c})\vec{b}-(\vec{a}·\vec{b})\vec{c}\]
</div>
</div>
<div class="paragraph">
<p>So in our case</p>
</div>
<div class="stemblock">
<div class="content">
\[\vec{v}×(\vec{v}×\vec{p})=(\vec{v}·\vec{p})\vec{v}-(\vec{v}·\vec{v})\vec{p}=(\vec{v}·\vec{p})\vec{v}-\left|\vec{v}\right|^{2}\vec{p}\]
</div>
</div>
<div class="paragraph">
<p>Remember \(q\) is unit quaternion, so \(\left|\vec{v}\right|^{2}+w^{2}=1\). We have</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
\vec{v}×(\vec{v}×\vec{p})&amp;=(\vec{v}·\vec{p})\vec{v}+w^{2}\vec{p}-\vec{p}\\
(\vec{v}·\vec{p})\vec{v}+w^{2}\vec{p}&amp;=\vec{v}×(\vec{v}×\vec{p})+\vec{p}\\
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Now we can simplify our rotation result to get rid of the dot product</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
\vec{p'}&amp;=\vec{p}+2w(\vec{v}×\vec{p})+2\vec{v}×(\vec{v}×\vec{p})\\
&amp;=\vec{p}+2(\vec{v}×(\vec{v}×\vec{p}+w\vec{p}))
\end{align*}\]
</div>
</div>
</div>
<div class="sect2">
<h3 id="_world_rotation_and_local_rotation">World Rotation and Local Rotation</h3>
<div class="paragraph">
<p>Let’s look at rotation composition again. The combined rotation \(q={q_2}{q_1}\) means rotating \(q_1\) first then \(q_2\). This right to left order only holds when \(q_2\) is a world rotation, or in another term the rotation axis \(\vec{v_2}\) of \(q_2\) is in world space. Then what if \(q_2\) is a local rotation, which means the rotation axis \(\vec{v_2}\) of \(q_2\) is in the local space after \(q_1\) rotation.</p>
</div>
<div class="paragraph">
<p>As an example of local rotation, imagine yourself lying down on the ground and facing up, now flip around to face the ground. What you just did is a \(180^{\circ}\) local rotation along Z axis. The rotation axis is not the world Z axis (which will be the up direction) but your local Z axis.</p>
</div>
<div class="paragraph">
<p>If we have an object with rotation \({q_1}=(\vec{v_1},{w_1})\), now we want to apply a local rotation \({q_{2L}}=(\vec{v_2},{w_2})\). We can convert the local rotation \(q_{2L}\) to world rotation \(q_{2W}\) by converting its rotation axis into world space. Since \(\vec{v_2}\) is in local space of \(q_1\), converting it into world space means rotating it by \(q_1\), so the world space rotation axis is \(\vec{v_{2W}}={q_1}\vec{v_2}{q_1}^{-1}\).</p>
</div>
<div class="paragraph">
<p>(Technically the rotation axis is \(\frac{\vec{v_2}}{\left|\vec{v_2}\right|}\), but since rotation angle is the same for local and world space, \(\left|\vec{v_2}\right|=\left|\vec{v_{2W}}\right|=\sin⁡\frac{θ}{2}\), we can just use \(\vec{v_2}\) in the calculation).</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
{q_{2W}}&amp;=(\vec{v_{2W}},{w_2})\\
&amp;=(\vec{v_{2W}},0)+(\vec{0},{w_2})\\
&amp;={q_1}(\vec{v_2},0){q_1}^{-1}+{q_1}(\vec{0},{w_2}){q_1}^{-1}\\
&amp;={q_1}(\vec{v_2},{w_2}){q_1}^{-1}\\
&amp;={q_1}{q_{2L}}{q_1}^{-1}\\
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>This equation tells us to convert a local rotation to world rotation, we can do the same as rotating a vector by using “sandwich” multiplication \({q_{2W}}={q_1}{q_{2L}}{q_1}^{-1}\). It also makes sense in geometric term. If we undo \(q_1\), now local space and world space are the same, we can then apply \(q_{2L}\) and apply \(q_1\) again to get the world rotation we want.</p>
</div>
<div class="paragraph">
<p>One thing I need to prove here</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
{q_1}(\vec{0},{w_2}){q_1}^{-1}&amp;=(\vec{v_1},{w_1})(\vec{0},{w_2})(-\vec{v_1},{w_1})\\
&amp;=({w_2}\vec{v_1},{w_1}{w_2})(-\vec{v_1},{w_1})\\
&amp;=(\vec{0},{w_2}(\left|\vec{v_1}\right|^{2}+{w_1}^{2}))\\
&amp;=(\vec{0},{w_2})\\
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>With the world rotation \(q_{2W}\) calculated, result of combined rotation is</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
q&amp;={q_{2W}}{q_1}\\
&amp;={q_1}{q_{2L}}{q_1}^{-1}{q_1}\\
&amp;={q_1}{q_{2L}}\\
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>This means when we rotate \(q_1\) then rotate \(q_2\), if \(q_2\) is in world space, then combined rotation is \(q={q_2}{q_1}\) (right to left); if \(q_2\) is in local space of \(q_1\), the combined rotation is \(q={q_1}{q_2}\) (left to right).</p>
</div>
</div>
<div class="sect2">
<h3 id="_rotation_along_x_y_z_axis">Rotation along X/Y/Z Axis</h3>
<div class="paragraph">
<p>We can now go back to the problem I mentioned at the very beginning: we need an object to face its opposite direction. More clearly we have an object with rotation \(q=((x,y,z),w)\), and we want to flip it along local Z axis, that is rotate it \(180^{\circ}\) along its local Z axis. This extra rotation is denoted as \(q'=((0,0,\sin\frac{180^{\circ}}{2}),\cos\frac{180^{\circ}}{2})=((0,0,1),0)\). Based on local rotation composition we proved in previous section, the result is</p>
</div>
<div class="stemblock">
<div class="content">
\[q_Z=qq'=((x,y,z),w)((0,0,1),0)=((y,-x,w),-z)\]
</div>
</div>
<div class="paragraph">
<p>If we generalize the angle to \(θ\), then \(q'=((0,0,\sin\frac{θ}{2}),\cos\frac{θ}{2})\), then the result is:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
q_{(Z,θ)}=qq'&amp;=((x,y,z),w)((0,0,\sin\frac{θ}{2},\cos\frac{θ}{2})\\
&amp;=((x,y,z),w)(((0,0,0),1)\cos\frac{θ}{2}+((0,0,1),0)\sin\frac{θ}{2})\\
&amp;=((x,y,z),w)\cos\frac{θ}{2}+((y,-x,w),-z)\sin\frac{θ}{2}\\
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>If we want to flip along world Z axis instead, we just need to change the multiplication order:</p>
</div>
<div class="stemblock">
<div class="content">
\[q_Z=q'q=((0,0,1),0)((x,y,z),w)=((-y,x,w),-z)\]
</div>
</div>
<div class="paragraph">
<p>We can use the same method to generalize the angle to \(θ\), and let \(q'=((0,0,\sin\frac{θ}{2}),\cos\frac{θ}{2})\),</p>
</div>
<div class="stemblock">
<div class="content">
\[q_{(Z,θ)}=q'q=((x,y,z),w)\cos\frac{θ}{2}+((-y,x,w),-z)\sin\frac{θ}{2})\]
</div>
</div>
<div class="paragraph">
<p>It is easy to extend the result to X and Y axis. I list the result summary as the following.</p>
</div>
<div class="paragraph">
<p>Flip along local axis:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
q_X&amp;=(w,z,-y,-x)\\
q_Y&amp;=(-z,w,x,-y)\\
q_Z&amp;=(y,-x,w,-z)\\
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Rotate \(θ\) along local axis:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
q_{(X,θ)}=(x,y,z,w)\cos\frac{θ}{2}+(w,z,-y,-x)\sin\frac{θ}{2}\\
q_{(Y,θ)}=(x,y,z,w)\cos\frac{θ}{2}+(-z,w,x,-y)\sin\frac{θ}{2}\\
q_{(Z,θ)}=(x,y,z,w)\cos\frac{θ}{2}+(y,-x,w,-z)\sin\frac{θ}{2}\\
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Flip along world axis:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
q_X&amp;=(w,-z,y,-x)\\
q_Y&amp;=(z,w,-x,-y)\\
q_Z&amp;=(-y,x,w,-z)\\
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Rotate \(θ\) along world axis:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
q_{(X,θ)}=(x,y,z,w)\cos\frac{θ}{2}+(w,-z,y,-x)\sin\frac{θ}{2}\\
q_{(Y,θ)}=(x,y,z,w)\cos\frac{θ}{2}+(z,w,-x,-y)\sin\frac{θ}{2}\\
q_{(Z,θ)}=(x,y,z,w)\cos\frac{θ}{2}+(-y,x,w,-z)\sin\frac{θ}{2}\\
\end{align*}\]
</div>
</div>
</div>
<div class="sect2">
<h3 id="_euler_angles_to_quaternion">Euler Angles to Quaternion</h3>
<div class="paragraph">
<p>Quaternion is an instruction for rotation: rotate angle \(θ\) along axis \(\vec{v}\). Euler angles is a sequence of 3 instructions: rotate yaw angle along world axis Z, then rotate pitch angle along local axis Y, then rotate roll angle along local axis X.</p>
</div>
<div class="paragraph">
<p>It is very natural to see how Euler angles can be converted to quaternion. If we use \(Y,P,R\) for angle yaw pitch and roll, then these 3 rotations to can be denoted in quaternion \(q_Y=(0,0,\sin\frac{Y}{2},\cos\frac{Y}{2})\), \(q_P=(0,\sin\frac{P}{2},0,\cos\frac{P}{2})\), \(q_R=(\sin\frac{R}{2},0,0,\cos\frac{R}{2})\). Since pitch and roll are local rotations, the combined rotation will be</p>
</div>
<div class="stemblock">
<div class="content">
\[q={q_Y}{q_P}{q_R}=(0,0,\sin\frac{Y}{2},\cos\frac{Y}{2})(0,\sin\frac{P}{2},0,\cos\frac{P}{2})(\sin\frac{R}{2},0,0,\cos\frac{R}{2})\]
</div>
</div>
<div class="paragraph">
<p>Solving this we have the conversion from Euler angles to quaternion.</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
x&amp;=\sin\frac{R}{2}\cos\frac{P}{2}\cos\frac{Y}{2}-\cos\frac{R}{2}\sin\frac{P}{2}\sin\frac{Y}{2}\\
y&amp;=\cos\frac{R}{2}\sin\frac{P}{2}\cos\frac{Y}{2}+\sin\frac{R}{2}\cos\frac{P}{2}\sin\frac{Y}{2}\\
z&amp;=\cos\frac{R}{2}\cos\frac{P}{2}\sin\frac{Y}{2}-\sin\frac{R}{2}\sin\frac{P}{2}\cos\frac{Y}{2}\\
w&amp;=\cos\frac{R}{2}\cos\frac{P}{2}\cos\frac{Y}{2}+\sin\frac{R}{2}\sin\frac{P}{2}\sin\frac{Y}{2}\\
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Converting quaternion to Euler angles, however, is tricky. It is easier if we convert quaternion to rotation matrix first then convert the rotation matrix to Euler angles, than trying to obtain the conversion directly. We will talk about this after the next section.</p>
</div>
</div>
<div class="sect2">
<h3 id="_quaternion_and_rotation_matrix">Quaternion and Rotation Matrix</h3>
<div class="paragraph">
<p>If we say quaternion is an instruction, Euler angles are 3 instructions, then the rotation matrix stores the rotation result directly. Remember each row of the rotation matrix is the X, Y, Z axis after this rotation, which means given a rotation \(q=(x,y,z,w)\), it’s corresponding rotation matrix is</p>
</div>
<div class="stemblock">
<div class="content">
\[M=\left[ \begin{array}{} \vec{X'} \\ \vec{Y'} \\ \vec{Z'} \end{array} \right]=\left[ \begin{array}{} q\vec{X}q^{-1} \\ q\vec{Y}q^{-1} \\ q\vec{Z}q^{-1} \end{array}  \right]\]
</div>
</div>
<div class="paragraph">
<p>By calculating the rotation result of the 3 axes, we get the conversion from quaternion to rotation matrix</p>
</div>
<div class="stemblock">
<div class="content">
\[M = \left[ \begin{array}{} 1-2y^{2}-2z^{2} &amp; 2xy+2zw &amp; 2xz-2yw \\ 2xy-2zw &amp; 1-2x^{2}-2z^{2} &amp; 2yz+2xw \\ 2xz+2yw &amp; 2yz-2xw &amp; 1-2x^{2}-2y^{2} \\ \end{array} \right]\]
</div>
</div>
<div class="paragraph">
<p>To convert from rotation matrix to quaternion, we can sum up diagonal elements of the matrix and get</p>
</div>
<div class="stemblock">
<div class="content">
\[M_{11}+M_{22}+M_{33}=3-4x^{2}-4y^{2}-4z^{2}\]
</div>
</div>
<div class="paragraph">
<p>Remember as a unit quaternion \(x^{2}+y^{2}+z^{2}+w^{2}=1\),</p>
</div>
<div class="stemblock">
<div class="content">
\[M_{11}+M_{22}+M_{33}= 4w^{2}-1\\
w=\frac{1}{2}\sqrt{M_{11}+M_{22}+M_{33}+1}\]
</div>
</div>
<div class="paragraph">
<p>Similarly we can obtain \(x,y,z\) by</p>
</div>
<div class="stemblock">
<div class="content">
\[M_{11}-M_{22}-M_{33}= 4x^{2}-1\\
M_{22}-M_{33}-M_{11}= 4y^{2}-1\\
M_{33}-M_{11}-M_{22}= 4z^{2}-1\\
x=\frac{1}{2}\sqrt{M_{11}-M_{22}-M_{33}+1}\\
y=\frac{1}{2}\sqrt{M_{22}-M_{33}-M_{11}+1}\\
z=\frac{1}{2}\sqrt{M_{33}-M_{11}-M_{22}+1}\\\]
</div>
</div>
<div class="paragraph">
<p>We can avoid calculating square root 4 times, by using the element we already calculated. Say we calculate \(w=\frac{1}{2}\sqrt{M_{11}+M_{22}+M_{33}+1}\) first, then we can get \(x,y,z\) by</p>
</div>
<div class="stemblock">
<div class="content">
\[x=\frac{1}{4w}(M_{23}-M_{32})\\
y=\frac{1}{4w}(M_{31}-M_{13})\\
z=\frac{1}{4w}(M_{12}-M_{21})\\\]
</div>
</div>
<div class="paragraph">
<p>You need to be careful if the value of \(w\) is closed to 0 (means \(M_{11}+M_{22}+M_{33}+1\) is closed to 0, no need to do square root).  In this case you want to calculate one of \(x,y,z\) instead. You can simply choose the one has the largest absolute value, and calculate the other 3 elements in a similar fashion.</p>
</div>
</div>
<div class="sect2">
<h3 id="_quaternion_to_euler_angles">Quaternion to Euler Angles</h3>
<div class="paragraph">
<p>Before we try to convert quaternion to Euler angles, let’s review how Euler angles can be converted to rotation matrix. As we know Euler angles are 3 instructions, it could be viewed as 3 rotation matrix:</p>
</div>
<div class="stemblock">
<div class="content">
\[M_R = \left[ \begin{array}{} 1 &amp; 0 &amp; 0 \\ 0 &amp; \cos{R} &amp; \sin{R} \\ 0 &amp; -\sin{R} &amp; \cos{R} \\ \end{array} \right],
M_P = \left[ \begin{array}{} \cos{P} &amp; 0 &amp; -\sin{P} \\ 0 &amp; 1 &amp; 0 \\ \sin{P} &amp; 0 &amp; \cos{P} \\ \end{array} \right],
M_Y = \left[ \begin{array}{} \cos{Y} &amp; \sin{Y} &amp; 0 \\ -\sin{Y} &amp; \cos{Y} &amp; 0 \\ 0 &amp; 0 &amp; 1 \\ \end{array} \right]\]
</div>
</div>
<div class="paragraph">
<p>The result rotation matrix is</p>
</div>
<div class="stemblock">
<div class="content">
\[M={M_R}{M_P}{M_Y}=\left[ \begin{array}{} \cos{P}\cos{Y} &amp; \cos{P}\sin{Y} &amp; -\sin{P} \\ \sin{R}\sin{P}\cos{Y}-\cos{R}\sin{Y} &amp; \sin{R}\sin{P}\sin{Y}+\cos{R}\cos{Y} &amp; \sin{R}\cos{P} \\ \cos{R}\sin{P}\cos{Y}+\sin{R}\sin{Y} &amp; \cos{R}\sin{P}\sin{Y}-\sin{R}\cos{Y} &amp; \cos{R}\cos{P} \\ \end{array} \right]\]
</div>
</div>
<div class="paragraph">
<p>You can also derive this by converting Euler angles to quaternion, then quaternion to rotation matrix, and by applying trigonometric double-angle formula you should get the same result.</p>
</div>
<div class="paragraph">
<p>If you put this result side by side with our quaternion to rotation matrix conversion, which I put here again for reference.</p>
</div>
<div class="stemblock">
<div class="content">
\[M = \left[ \begin{array}{} 1-2y^{2}-2z^{2} &amp; 2xy+2zw &amp; 2xz-2yw \\ 2xy-2zw &amp; 1-2x^{2}-2z^{2} &amp; 2yz+2xw \\ 2xz+2yw &amp; 2yz-2xw &amp; 1-2x^{2}-2y^{2} \\ \end{array} \right]\]
</div>
</div>
<div class="paragraph">
<p>You can easily spot this:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
\cos{P}\cos{Y}&amp;=1-2y^{2}-2z^{2}\\
\cos{P}\sin{Y}&amp;=2xy+2zw\\
-\sin{P}&amp;=2xz-2yw\\
\sin{R}\cos{P}&amp;=2yz+2xw\\
\cos{R}\cos{P}&amp;=1-2x^{2}-2y^{2}\\
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Now we can write down the conversion from quaternion to Euler angles</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
P&amp;=\mathrm{asin}(-2xy+2yw)\\
Y&amp;=\mathrm{atan2}(2xy+2zw,1-2y^{2}-2z^{2})\\
R&amp;=\mathrm{atan2}(2yz+2xw,1-2x^{2}-2y^{2})\\
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>However we still have a problem when pitch is near \(90^{\circ}\) or \(-90^{\circ}\). This is called singularity. This issue is explained more in <a href="http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToEuler/">this website</a>. In this case \(\cos{⁡P}=0,\sin{⁡P}=1\) or \(\cos{⁡P}=0,\sin{⁡}P=-1\), and the rotation matrix becomes:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
M_{90^{\circ}}&amp;=\left[ \begin{array}{} 0 &amp; 0 &amp; -1 \\ \sin{R}\cos{Y}-\cos{R}\sin{Y} &amp; \sin{R}\sin{Y}+\cos{R}\cos{Y} &amp; 0 \\ \cos{R}\cos{Y}+\sin{R}\sin{Y} &amp; \cos{R}\sin{Y}-\sin{R}\cos{Y} &amp; 0 \\ \end{array} \right] = \left[ \begin{array}{} 0 &amp; 0 &amp; -1 \\ \sin(R-Y) &amp; \cos(R-Y) &amp; 0 \\ \cos(R-Y) &amp; -\sin(R-Y) &amp; 0 \\ \end{array} \right]\\
M_{-90^{\circ}}&amp;=\left[ \begin{array}{} 0 &amp; 0 &amp; 1 \\ -\sin{R}\cos{Y}-\cos{R}\sin{Y} &amp; -\sin{R}\sin{Y}+\cos{R}\cos{Y} &amp; 0 \\ -\cos{R}\cos{Y}+\sin{R}\sin{Y} &amp; -\cos{R}\sin{Y}-\sin{R}\cos{Y} &amp; 0 \\ \end{array} \right] = \left[ \begin{array}{} 0 &amp; 0 &amp; 1 \\ -\sin(R+Y) &amp; \cos(R+Y) &amp; 0 \\ -\cos(R+Y) &amp; -\sin(R+Y) &amp; 0 \\ \end{array} \right]\\
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>The formula we used to calculate yaw and roll becomes \(\mathrm{atan2}(0,0)\), which will give an invalid value.</p>
</div>
<div class="paragraph">
<p>We need to go a different way, recall the conversion from Euler angles to quaternion.</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
x&amp;=\sin\frac{R}{2}\cos\frac{P}{2}\cos\frac{Y}{2}-\cos\frac{R}{2}\sin\frac{P}{2}\sin\frac{Y}{2}\\
y&amp;=\cos\frac{R}{2}\sin\frac{P}{2}\cos\frac{Y}{2}+\sin\frac{R}{2}\cos\frac{P}{2}\sin\frac{Y}{2}\\
z&amp;=\cos\frac{R}{2}\cos\frac{P}{2}\sin\frac{Y}{2}-\sin\frac{R}{2}\sin\frac{P}{2}\cos\frac{Y}{2}\\
w&amp;=\cos\frac{R}{2}\cos\frac{P}{2}\cos\frac{Y}{2}+\sin\frac{R}{2}\sin\frac{P}{2}\sin\frac{Y}{2}\\
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>If \(P=90^{\circ}\), then \(x=-z=\frac{\sqrt{2}}{2}\sin\frac{R-Y}{2}\), \(y=w=\frac{\sqrt{2}}{2}\cos\frac{R-Y}{2}\), then we have</p>
</div>
<div class="stemblock">
<div class="content">
\[R-Y=2\mathrm{atan2}(x,w)\]
</div>
</div>
<div class="paragraph">
<p>Similarly, if \(P=-90^{\circ}\), then \(x=z=\frac{\sqrt{2}}{2}\sin\frac{R+Y}{2}\), \(-y=w=\frac{\sqrt{2}}{2}\cos\frac{R+Y}{2}\), then we have</p>
</div>
<div class="stemblock">
<div class="content">
\[R+Y=2\mathrm{atan2}(x,w)\]
</div>
</div>
<div class="paragraph">
<p>Imagine an airplane facing straight up or down, yaw and roll basically means rotating along the same axis. We can simply let yaw be zero, and only calculate roll. So if \(P≈±90^{\circ}\), then</p>
</div>
<div class="stemblock">
<div class="content">
\[Y=0, R=2\mathrm{atan2}(x,w)\]
</div>
</div>
<div class="paragraph">
<p>Finally, since \(\sin{⁡P}=-2xz+2yw\), we only need to test \(-2xz+2yw≈±1\) to test if pitch is near \(±90^{\circ}\).</p>
</div>
</div>
<div class="sect2">
<h3 id="_summary_of_part_2">Summary of Part 2</h3>
<div class="paragraph">
<p>In Part 2 we talked about different multiplication order for combining world rotations or local rotations.</p>
</div>
<div class="paragraph">
<p>We derive the formula to calculate the result of rotating a vector by a quaternion. We also find out a quick way to apply rotation along X/Y/Z axis.</p>
</div>
<div class="paragraph">
<p>We discussed conversion between quaternion, Euler angles and rotation matrix.</p>
</div>
<div class="paragraph">
<p>As you can see whenever you get or set Euler angles in the game engine, you are doing a conversion from or to quaternion, and there will be trigonometric calculation involved. Try to avoid them if you can do quaternion calculation directly.</p>
</div>
<div class="paragraph">
<p>Also some systems use left-handed or Y up coordinate, or have different Euler angles convention. Be sure you understand the system you are using, since quaternion and Euler angles conversion will be very different.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_appendix">Appendix</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_derive_quaternion_multiplication">Derive Quaternion Multiplication</h3>
<div class="paragraph">
<p>We can actually derive the general quaternion multiplication from the special flip break down \(q_1=-{q_c}{q_a}\), \(q_2=-{q_b}{q_c}\), we used to visualize the result of rotation composition. That is if we define flip multiplication \({q_a}{q_b}=(\vec{a},0)(\vec{b},0)=(\vec{a}×\vec{b},-\vec{a}·\vec{b})\) directly, we can proof what general quaternion multiplication \({q_1}{q_2}=(\sin⁡\frac{θ_1}{2}\vec{v_1},\cos⁡\frac{θ_1}{2})(\sin⁡\frac{θ_2}{2}\vec{v_2},\cos⁡\frac{θ_2}{2})\) would look like. If you don’t remember this, see <a href="#_rotation_composition">Rotation Composition</a> section in Part 1.</p>
</div>
<div class="paragraph">
<p>Here are some equations we will be using:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
\vec{a}×(\vec{b}×\vec{c})&amp;=(\vec{a}·\vec{c})\vec{b}-(\vec{a}·\vec{b})\vec{c}\\
(\vec{a}×\vec{b})·(\vec{c}×\vec{d})&amp;=(\vec{a}·\vec{c})(\vec{b}·\vec{d})-(\vec{a}·\vec{d})(\vec{b}·\vec{c})\\
(\vec{a}×\vec{b})×(\vec{a}×\vec{c})&amp;=(\vec{a}·(\vec{b}×\vec{c}))\vec{a}
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Recall how we choose the flip break down \(\vec{c}=\frac{\vec{v_1}×\vec{v_2}}{\left|\vec{v_1}×\vec{v_2}\right|}\).</p>
</div>
<div class="paragraph">
<p>Rotate \(\vec{c}\) along axis \(\vec{v_1}\) by angle \(-\frac{θ_1}{2}\) we get</p>
</div>
<div class="stemblock">
<div class="content">
\[\vec{a}=\cos\frac{-θ_1}{2}\vec{c} + \sin\frac{-θ_1}{2}(\vec{v_1}×\vec{c})=\frac{1}{\left|\vec{v_1}×\vec{v_2}\right|}(\cos\frac{θ_1}{2}(\vec{v_1}×\vec{v_2}) - \sin\frac{θ_1}{2}(\vec{v_1}×(\vec{v_1}×\vec{v_2})))\]
</div>
</div>
<div class="paragraph">
<p>Rotate \(\vec{c}\) along axis \(\vec{v_2}\) by angle \(\frac{θ_2}{2}\) we get</p>
</div>
<div class="stemblock">
<div class="content">
\[\vec{b}=\cos\frac{θ_2}{2}\vec{c} + \sin\frac{θ_2}{2}(\vec{v_2}×\vec{c})=\frac{1}{\left|\vec{v_1}×\vec{v_2}\right|}(\cos\frac{θ_2}{2}(\vec{v_1}×\vec{v_2}) + \sin\frac{θ_2}{2}(\vec{v_2}×(\vec{v_1}×\vec{v_2})))\]
</div>
</div>
<div class="paragraph">
<p>And we will have</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
\vec{a}·\vec{b}&amp;=\frac{1}{{\left|\vec{v_1}×\vec{v_2}\right|}^{2}}(\cos\frac{θ_1}{2}\cos\frac{θ_2}{2}{\left|\vec{v_1}×\vec{v_2}\right|}^{2} - \sin\frac{θ_1}{2}\sin\frac{θ_2}{2}((\vec{v_1}×(\vec{v_1}×\vec{v_2}))·(\vec{v_2}×(\vec{v_1}×\vec{v_2}))))\\
&amp;=\frac{1}{{\left|\vec{v_1}×\vec{v_2}\right|}^{2}}(\cos\frac{θ_1}{2}\cos\frac{θ_2}{2}{\left|\vec{v_1}×\vec{v_2}\right|}^{2} - \sin\frac{θ_1}{2}\sin\frac{θ_2}{2}(\vec{v_1}·\vec{v_2}){\left|\vec{v_1}×\vec{v_2}\right|}^{2})\\
&amp;=\cos\frac{θ_1}{2}\cos\frac{θ_2}{2} - \sin\frac{θ_1}{2}\sin\frac{θ_2}{2}(\vec{v_1}·\vec{v_2})
\end{align*}\]
</div>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
\vec{a}×\vec{b}&amp;=\frac{1}{{\left|\vec{v_1}×\vec{v_2}\right|}^{2}}(\cos\frac{θ_1}{2}\sin\frac{θ_2}{2}((\vec{v_1}×\vec{v_2})×(\vec{v_2}×(\vec{v_1}×\vec{v_2})))\\
&amp;- \sin\frac{θ_1}{2}\cos\frac{θ_2}{2}((\vec{v_1}×(\vec{v_1}×\vec{v_2}))×(\vec{v_1}×\vec{v_2})\\
&amp;- \sin\frac{θ_1}{2}\sin\frac{θ_2}{2}((\vec{v_1}×(\vec{v_1}×\vec{v_2}))×(\vec{v_2}×(\vec{v_1}×\vec{v_2}))))\\
&amp;=\frac{1}{{\left|\vec{v_1}×\vec{v_2}\right|}^{2}}(\cos\frac{θ_1}{2}\sin\frac{θ_2}{2}{\left|\vec{v_1}×\vec{v_2}\right|}^{2}\vec{v_2} + \sin\frac{θ_1}{2}\cos\frac{θ_2}{2}{\left|\vec{v_1}×\vec{v_2}\right|}^{2}\vec{v_1} - \sin\frac{θ_1}{2}\sin\frac{θ_2}{2}{\left|\vec{v_1}×\vec{v_2}\right|}^{2}(\vec{v_1}×\vec{v_2}))\\
&amp;=\cos\frac{θ_1}{2}\sin\frac{θ_2}{2}\vec{v_2} + \sin\frac{θ_1}{2}\cos\frac{θ_2}{2}\vec{v_1} - \sin\frac{θ_1}{2}\sin\frac{θ_2}{2}(\vec{v_1}×\vec{v_2})
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>From the previous proof of rotation composition we know \(q={q_2}{q_1}=-{q_b}{q_a}\), that is</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
q&amp;=(\vec{a}×\vec{b},\vec{a}·\vec{b})\\
&amp;=(\cos\frac{θ_1}{2}(\sin\frac{θ_2}{2}\vec{v_2}) + \cos\frac{θ_2}{2}(\sin\frac{θ_1}{2}\vec{v_1}) - (\sin\frac{θ_1}{2}\vec{v_1})×(\sin\frac{θ_2}{2}\vec{v_2}), \cos\frac{θ_1}{2}\cos\frac{θ_2}{2} - (\sin\frac{θ_1}{2}\vec{v_1})·(\sin\frac{θ_2}{2}\vec{v_2}))
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>which is the definition of quaternion multiplication of \({q_1}{q_2}=(\sin⁡\frac{θ_1}{2}\vec{v_1},\cos⁡\frac{θ_1}{2})(\sin⁡\frac{θ_2}{2}\vec{v_2},\cos⁡\frac{θ_2}{2})\).</p>
</div>
</div>
</div>
</div>]]></description><link>https://lxjk.github.io/2016/10/29/A-Different-Way-to-Understand-Quaternion-and-Rotation.html</link><guid isPermaLink="true">https://lxjk.github.io/2016/10/29/A-Different-Way-to-Understand-Quaternion-and-Rotation.html</guid><dc:creator><![CDATA[Eric Zhang]]></dc:creator><pubDate>Sat, 29 Oct 2016 00:00:00 GMT</pubDate></item></channel></rss>