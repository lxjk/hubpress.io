<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <title>Fast 4x4 Matrix Inverse with SSE SIMD, Explained - Eric&#x27;s Blog</title>

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Fast 4x4 Matrix Inverse with SSE SIMD, Explained">
    <meta name="twitter:description" content="">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Fast 4x4 Matrix Inverse with SSE SIMD, Explained">
    <meta property="og:description" content="">

    <link href="/favicon.ico" rel="shortcut icon" type="image/x-icon">
    <link href="/apple-touch-icon-precomposed.png" rel="apple-touch-icon">

    <link rel="stylesheet" type="text/css" href="//lxjk.github.io/themes/uno/assets/css/uno.css?v=1504482311354" />
    <link rel="stylesheet" href="//lxjk.github.io/themes/uno/assets/css/asciidoctor-foundation.css?v=1504482311354"/>

    <script type="text/javascript" async
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
	
    <link rel="canonical" href="https://lxjk.github.io/2017/09/03/Fast-4x4-Matrix-Inverse-with-SSE-SIMD-Explained.html" />
    <meta name="referrer" content="origin" />
    
    <meta property="og:site_name" content="Eric&#x27;s Blog" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Fast 4x4 Matrix Inverse with SSE SIMD, Explained" />
    <meta property="og:description" content="Table of Contents Transform Matrix Inverse General Matrix Inverse Appendix Before we start, think about this question: do we really need the inverse of a general matrix? I came to this problem when writing a math library for my game engine. If you are making a game or 3D application," />
    <meta property="og:url" content="https://lxjk.github.io/2017/09/03/Fast-4x4-Matrix-Inverse-with-SSE-SIMD-Explained.html" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="Fast 4x4 Matrix Inverse with SSE SIMD, Explained" />
    <meta name="twitter:description" content="Table of Contents Transform Matrix Inverse General Matrix Inverse Appendix Before we start, think about this question: do we really need the inverse of a general matrix? I came to this problem when writing a math library for my game engine. If you are making a game or 3D application," />
    <meta name="twitter:url" content="https://lxjk.github.io/2017/09/03/Fast-4x4-Matrix-Inverse-with-SSE-SIMD-Explained.html" />
    
    <script type="application/ld+json">
null
    </script>

    <meta name="generator" content="HubPress" />
    <link rel="alternate" type="application/rss+xml" title="Eric&#x27;s Blog" href="https://lxjk.github.io/rss/" />

</head>
<body class="post-template no-js">

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    <header class="panel-cover panel-cover--collapsed " >
      <div class="panel-main">
    
        <div class="panel-main__inner panel-inverted">
        <div class="panel-main__content">
    
            <h1 class="panel-cover__title panel-title"><a href="https://lxjk.github.io" title="link to homepage for Eric&#x27;s Blog">Eric&#x27;s Blog</a></h1>
            <hr class="panel-cover__divider" />
            <p class="panel-cover__description">- Game Dev - Tool Dev - Math - Machine Learning -</p>
            <hr class="panel-cover__divider panel-cover__divider--secondary" />
    
            <div class="navigation-wrapper">
    
              <nav class="cover-navigation cover-navigation--primary">
                <ul class="navigation">
                  <li class="navigation__item"><a href="https://lxjk.github.io/#blog" title="link to Eric&#x27;s Blog blog" class="blog-button">Blog</a></li>
                </ul>
              </nav>
    
              
              
              <nav class="cover-navigation navigation--social">
                <ul class="navigation">
              
              
              
              
              
              
              
              
                  <!-- LinkedIn -->
                  <li class="navigation__item">
                    <a href="https://www.linkedin.com/in/lxjk001" title="LinkedIn account">
                      <i class='icon icon-social-linkedin'></i>
                      <span class="label">LinkedIn</span>
                    </a>
                  </li>
              
                  <!-- Email -->
                  <li class="navigation__item">
                    <a href="mailto:lxjk001@gmail.com" title="Email lxjk001@gmail.com">
                      <i class='icon icon-mail'></i>
                      <span class="label">Email</span>
                    </a>
                  </li>
              
                </ul>
              </nav>
              
    
            </div>
    
          </div>
    
        </div>
    
        <div class="panel-cover--overlay"></div>
      </div>
    </header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            

  <article class="post-container post-container--single">

    <header class="post-header">
      <div class="post-meta">
        <time datetime="Sep 03 2017" class="post-meta__date date">Sep 03 2017</time> &#8226; <span class="post-meta__tags tags"></span>
        <span class="post-meta__author author"><img src="https://avatars0.githubusercontent.com/u/3803294?v&#x3D;4" alt="profile image for Eric Zhang" class="avatar post-meta__avatar" /> by Eric Zhang</span>
      </div>
      <h1 class="post-title">Fast 4x4 Matrix Inverse with SSE SIMD, Explained</h1>
    </header>

    <section class="post">
      <div id="preamble">
<div class="sectionbody">
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel2">
<li><a href="#_transform_matrix_inverse">Transform Matrix Inverse</a></li>
<li><a href="#_general_matrix_inverse">General Matrix Inverse</a></li>
<li><a href="#_appendix">Appendix</a></li>
</ul>
</div>
<div class="paragraph">
<p>Before we start, think about this question: do we really need the inverse of a general matrix?</p>
</div>
<div class="paragraph">
<p>I came to this problem when writing a math library for my game engine. If you are making a game or 3D application, we use 4x4 matrix for object transform, which is a combination of 3D translation, rotation and scale. If most of your matrix are used as transform matrix, because of their special property, we have a fast route for calculating their inverse. In fact transform matrix inverse is only 50% of the cost compared to the optimized general matrix inverse. In the first half of this post we will talk about transform matrix.  In the second half we will dive in and explain the SIMD version of general 4x4 matrix inverse, and we compare the performance of our method with commonly used math libraries from UE4, Eigen and DirectX Math.</p>
</div>
<div class="paragraph">
<p>The matrices used in this post are row major. This is mainly for (1) easier to demonstrate and visualize with matrix data layout; (2) easier to compare with other math library. The same matrix inverse function works for both row major and column major, because \(A^{-1}=((A^{T})^{-1})^{T}\) (inverse is the same as transpose, inverse then transpose again). However if you are a column major guy like myself, I have a full-on column major version for you in <a href="#_appendix">Appendix</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_transform_matrix_inverse">Transform Matrix Inverse</h3>
<div class="paragraph">
<p>The transform matrix we are talking about here is defined as following:</p>
</div>
<div class="stemblock">
<div class="content">
\[M=\begin{matrix} a\vec{X} &amp; 0 \\ b\vec{Y} &amp; 0 \\ c\vec{Z} &amp; 0 \\ \vec{T} &amp; 1 \\ \end{matrix}= \begin{matrix} aX_0 &amp; aX_1 &amp; aX_2 &amp; 0 \\ bY_0 &amp; bY_1 &amp; bY_2 &amp; 0 \\ cZ_0 &amp; cZ_1 &amp; cZ_2 &amp; 0 \\ T_0 &amp; T_1 &amp; T_2 &amp; 1 \\ \end{matrix}\]
</div>
</div>
<div class="paragraph">
<p>The first 3 component of the last row is the translation \(\vec{T}\). The top left 3x3 sub-matrix is the scaled rotation matrix, with each row as a scaled axis. We have \(\vec{X}\cdot\vec{Y}=\vec{X}\cdot\vec{Z}=\vec{Y}\cdot\vec{Z}=0\), and \(\left|\vec{X}\right|=\left|\vec{Y}\right|=\left|\vec{Z}\right|=1\). And the scale is \((a,b,c)\).</p>
</div>
<div class="paragraph">
<p>Most matrices in the game are of this form. For example, \(M\) represents a local to world transform, \(\vec{X}\), \(\vec{Y}\), \(\vec{Z}\) are your local space axes. If you have a point \(\vec{P}(P_0,P_1,P_2)\), and you want to transform it from local space to world space, you do this:</p>
</div>
<div class="stemblock">
<div class="content">
\[\vec{P'}=P_0a\vec{X}+P_1b\vec{Y}+P_2c\vec{Z}+\vec{T}\]
</div>
</div>
<div class="paragraph">
<p>This is the same as extend \(\vec{P}\) to a 4 component vector \(\vec{P}(P_0,P_1,P_2,1)\) and multiply by matrix \(M\). Now what does inverse matrix \(M^{-1}\) mean? In this case it represents a world to local transform, so if we multiply \(\vec{P'}\) by \(M^{-1}\), we should get \(\vec{P}\) back. How do we transform the point \(\vec{P'}\) in world space back in local space? We subtract the local space origin (aka the translation \(\vec{T}\)), then dot each axes to get its local space coordinate and rescale it:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
\vec{P}&amp;=(\frac{1}{a}(\vec{P'}-\vec{T})\cdot\vec{X},\frac{1}{b}(\vec{P'}-\vec{T})\cdot\vec{Y},\frac{1}{c}(\vec{P'}-\vec{T})\cdot\vec{Z})\\
&amp;=(\frac{1}{a}\vec{P'}\cdot\vec{X},\frac{1}{b}\vec{P'}\cdot\vec{Y},\frac{1}{c}\vec{P'}\cdot\vec{Z})-(\frac{1}{a}\vec{T}\cdot\vec{X},\frac{1}{b}\vec{T}\cdot\vec{Y},\frac{1}{c}\vec{T}\cdot\vec{Z})
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>With this, we can actually directly write the form of the inverse of our matrix.</p>
</div>
<div class="stemblock">
<div class="content">
\[M^{-1}=\begin{matrix} \frac{1}{a}\vec{X} &amp; \frac{1}{b}\vec{Y} &amp; \frac{1}{c}\vec{Z} &amp; \vec{0} \\ -\vec{T}\cdot\frac{1}{a}\vec{X} &amp; -\vec{T}\cdot\frac{1}{b}\vec{Y} &amp; -\vec{T}\cdot\frac{1}{c}\vec{Z} &amp; 1 \\ \end{matrix}= \begin{matrix} \frac{1}{a}X_0 &amp; \frac{1}{b}Y_0 &amp; \frac{1}{c}Z_0 &amp; 0 \\ \frac{1}{a}X_1 &amp; \frac{1}{b}Y_1 &amp; \frac{1}{c}Z_1 &amp; 0 \\ \frac{1}{a}X_2 &amp; \frac{1}{b}Y_2 &amp; \frac{1}{c}Z_2 &amp; 0 \\ -\vec{T}\cdot\frac{1}{a}\vec{X} &amp; -\vec{T}\cdot\frac{1}{b}\vec{Y} &amp; -\vec{T}\cdot\frac{1}{c}\vec{Z} &amp; 1 \\ \end{matrix}\]
</div>
</div>
<div class="paragraph">
<p>The nice thing about transform matrix \(M\) is its first 3 rows are perpendicular to each other. Its inverse form is basically transpose the 3x3 rotation matrix, and rescale it, and change translation part by doing dot product with 3 rescaled axes. It should be easy to confirm \(MM^{-1}=I\).</p>
</div>
<div class="paragraph">
<p>Now let’s bake in the scale (so \(\left|\vec{X}\right|=a\),\(\left|\vec{Y}\right|=b\),\(\left|\vec{Z}\right|=c\)) and get a more generic form.</p>
</div>
<div class="stemblock">
<div class="content">
\[M=\begin{matrix} \vec{X} &amp; 0 \\ \vec{Y} &amp; 0 \\ \vec{Z} &amp; 0 \\ \vec{T} &amp; 1 \\ \end{matrix}, M^{-1}=\begin{matrix} \frac{1}{{\left|\vec{X}\right|}^{2}}\vec{X} &amp; \frac{1}{{\left|\vec{Y}\right|}^{2}}\vec{Y} &amp; \frac{1}{{\left|\vec{Z}\right|}^{2}}\vec{Z} &amp; \vec{0} \\ -\vec{T}\cdot\frac{1}{{\left|\vec{X}\right|}^{2}}\vec{X} &amp; -\vec{T}\cdot\frac{1}{{\left|\vec{Y}\right|}^{2}}\vec{Y} &amp; -\vec{T}\cdot\frac{1}{{\left|\vec{Z}\right|}^{2}}\vec{Z} &amp; 1 \\ \end{matrix}\]
</div>
</div>
<div class="paragraph">
<p>Notice that for rescaling, we divide by squared size of scaled axis, instead of size, which is a good new for implementation. And if our transform is of unit scale, which is also common in games, our target becomes even simpler.</p>
</div>
<div class="stemblock">
<div class="content">
\[M^{-1}=\begin{matrix} \vec{X} &amp; \vec{Y} &amp; \vec{Z} &amp; \vec{0} \\ -\vec{T}\cdot\vec{X} &amp; -\vec{T}\cdot\vec{Y} &amp; -\vec{T}\cdot\vec{Z} &amp; 1 \\ \end{matrix}\]
</div>
</div>
<div class="paragraph">
<p>Alright, enough theory, let’s see some code. This is our matrix definition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c++" data-lang="c++">__declspec(align(16)) struct Matrix4
{
public:
	union
	{
		float m[4][4];
		__m128 mVec[4];
	};
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Before we jump in intrinsics, I would like to define a bunch of shuffle/swizzle macros. Hopefully they will make it easier to read. We also make use of faster instructions for special shuffles.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c++" data-lang="c++">#define MakeShuffleMask(x,y,z,w)			(x | (y&lt;&lt;2) | (z&lt;&lt;4) | (w&lt;&lt;6))

// vec(0, 1, 2, 3) -&gt; (vec[x], vec[y], vec[z], vec[w])
#define VecSwizzle(vec, x,y,z,w)			_mm_shuffle_ps(vec, vec, MakeShuffleMask(x,y,z,w))
#define VecSwizzle1(vec, x) 				_mm_shuffle_ps(vec, vec, MakeShuffleMask(x,x,x,x))
// special swizzle
#define VecSwizzle_0101(vec)				_mm_movelh_ps(vec, vec)
#define VecSwizzle_2323(vec)				_mm_movehl_ps(vec, vec)
#define VecSwizzle_0022(vec)				_mm_moveldup_ps(vec)
#define VecSwizzle_1133(vec)				_mm_movehdup_ps(vec)

// return (vec1[x], vec1[y], vec2[z], vec2[w])
#define VecShuffle(vec1, vec2, x,y,z,w)		_mm_shuffle_ps(vec1, vec2, MakeShuffleMask(x,y,z,w))
// special shuffle
#define VecShuffle_0101(vec1, vec2)			_mm_movelh_ps(vec1, vec2)
#define VecShuffle_2323(vec1, vec2)			_mm_movehl_ps(vec2, vec1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is our first function to inverse transform matrix without scaling (always unit scale).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c++" data-lang="c++">// Requires this matrix to be transform matrix, NoScale version requires this matrix be of scale 1
inline Matrix4 GetTransformInverseNoScale(const Matrix4&amp; inM)
{
	Matrix4 r;

	// transpose 3x3, we know m03 = m13 = m23 = 0
	__m128 t0 = VecShuffle_0101(inM.mVec[0], inM.mVec[1]); // 00, 01, 10, 11
	__m128 t1 = VecShuffle_2323(inM.mVec[0], inM.mVec[1]); // 02, 03, 12, 13
	r.mVec[0] = VecShuffle(t0, inM.mVec[2], 0,2,0,3); // 00, 10, 20, 23(=0)
	r.mVec[1] = VecShuffle(t0, inM.mVec[2], 1,3,1,3); // 01, 11, 21, 23(=0)
	r.mVec[2] = VecShuffle(t1, inM.mVec[2], 0,2,2,3); // 02, 12, 22, 23(=0)

	// last line
	r.mVec[3] =							_mm_mul_ps(r.mVec[0], VecSwizzle1(inM.mVec[3], 0));
	r.mVec[3] = _mm_add_ps(r.mVec[3],	_mm_mul_ps(r.mVec[1], VecSwizzle1(inM.mVec[3], 1)));
	r.mVec[3] = _mm_add_ps(r.mVec[3],	_mm_mul_ps(r.mVec[2], VecSwizzle1(inM.mVec[3], 2)));
	r.mVec[3] = _mm_sub_ps(_mm_setr_ps(0.f, 0.f, 0.f, 1.f), r.mVec[3]);

	return r;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Very straight forward. This is the fastest function you can have, it only does a transpose and some dot products. If we add in scales, it takes a little more time to do rescaling, but still pretty fast. There is a little trick for calculating squared size, we can make use of the fact that we need to transpose 3x3 rotation part anyway, do squared size after and calculate 3 axes in one go.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c++" data-lang="c++">#define SMALL_NUMBER		(1.e-8f)

// Requires this matrix to be transform matrix
inline Matrix4 GetTransformInverse(const Matrix4&amp; inM)
{
	Matrix4 r;

	// transpose 3x3, we know m03 = m13 = m23 = 0
	__m128 t0 = VecShuffle_0101(inM.mVec[0], inM.mVec[1]); // 00, 01, 10, 11
	__m128 t1 = VecShuffle_2323(inM.mVec[0], inM.mVec[1]); // 02, 03, 12, 13
	r.mVec[0] = VecShuffle(t0, inM.mVec[2], 0,2,0,3); // 00, 10, 20, 23(=0)
	r.mVec[1] = VecShuffle(t0, inM.mVec[2], 1,3,1,3); // 01, 11, 21, 23(=0)
	r.mVec[2] = VecShuffle(t1, inM.mVec[2], 0,2,2,3); // 02, 12, 22, 23(=0)

	// (SizeSqr(mVec[0]), SizeSqr(mVec[1]), SizeSqr(mVec[2]), 0)
	__m128 sizeSqr;
	sizeSqr =						_mm_mul_ps(r.mVec[0], r.mVec[0]);
	sizeSqr = _mm_add_ps(sizeSqr,	_mm_mul_ps(r.mVec[1], r.mVec[1]));
	sizeSqr = _mm_add_ps(sizeSqr,	_mm_mul_ps(r.mVec[2], r.mVec[2]));

	// optional test to avoid divide by 0
	__m128 one = _mm_set1_ps(1.f);
	// for each component, if(sizeSqr &lt; SMALL_NUMBER) sizeSqr = 1;
	__m128 rSizeSqr = _mm_blendv_ps(
		_mm_div_ps(one, sizeSqr),
		one,
		_mm_cmplt_ps(sizeSqr, _mm_set1_ps(SMALL_NUMBER))
		);

	r.mVec[0] = _mm_mul_ps(r.mVec[0], rSizeSqr);
	r.mVec[1] = _mm_mul_ps(r.mVec[1], rSizeSqr);
	r.mVec[2] = _mm_mul_ps(r.mVec[2], rSizeSqr);

	// last line
	r.mVec[3] =							_mm_mul_ps(r.mVec[0], VecSwizzle1(inM.mVec[3], 0));
	r.mVec[3] = _mm_add_ps(r.mVec[3],	_mm_mul_ps(r.mVec[1], VecSwizzle1(inM.mVec[3], 1)));
	r.mVec[3] = _mm_add_ps(r.mVec[3],	_mm_mul_ps(r.mVec[2], VecSwizzle1(inM.mVec[3], 2)));
	r.mVec[3] = _mm_sub_ps(_mm_setr_ps(0.f, 0.f, 0.f, 1.f), r.mVec[3]);

	return r;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice the top and bottom of the function is exactly the same as the NoScale version. In the middle we calculate squared size, with an optional divide-by-small-number test.</p>
</div>
</div>
<div class="sect2">
<h3 id="_general_matrix_inverse">General Matrix Inverse</h3>
<div class="paragraph">
<p>For general matrix, things are getting complicated. You can find most of the theory part in the following wiki pages:
<a href="https://en.wikipedia.org/wiki/Invertible_matrix">Invertible Matrix</a>, <a href="https://en.wikipedia.org/wiki/Adjugate_matrix">Adjugate Matrix</a>, <a href="https://en.wikipedia.org/wiki/Determinant#Relation_to_eigenvalues_and_trace">Determinant</a>, <a href="https://en.wikipedia.org/wiki/Trace_(linear_algebra)">Trace</a>.</p>
</div>
<div class="paragraph">
<p>We will introduce some of them as we go. The method is based on the same block matrices method Intel used for its <a href="https://software.intel.com/en-us/articles/optimized-matrix-library-for-use-with-the-intel-pentiumr-4-processors-sse2-instructions/">Optimized Matrix Library</a>.</p>
</div>
<div class="paragraph">
<p>A 4x4 matrix can be described as 4 2x2 sub matrices. The good things about 2x2 matrix are not only it is easy to calculate their inverse or determinant, but also because they can fit in one vector register, their calculation can be done very fast.</p>
</div>
<div class="stemblock">
<div class="content">
\[M=\begin{matrix} A &amp; B \\ C &amp; D \\ \end{matrix}=\begin{matrix} A_0 &amp; A_1 &amp; B_0 &amp; B_1 \\ A_2 &amp; A_3 &amp; B_2 &amp; B_3 \\ C_0 &amp; C_1 &amp; D_0 &amp; D_1 \\ C_2 &amp; C_3 &amp; D_2 &amp; D_3 \\ \end{matrix}\]
</div>
</div>
<div class="paragraph">
<p>Matrix block-wise inverse is given by the following:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
{\begin{matrix} A &amp; B \\ C &amp; D \\ \end{matrix}}^{-1}&amp;=\begin{matrix} A^{-1}+A^{-1}B(D-CA^{-1}B)^{-1}CA^{-1} &amp; -A^{-1}B(D-CA^{-1}B)^{-1} \\ -(D-CA^{-1}B)^{-1}CA^{-1} &amp; (D-CA^{-1}B)^{-1} \\ \end{matrix}\\
&amp;=\begin{matrix} (A-BD^{-1}C)^{-1} &amp; -(A-BD^{-1}C)^{-1}BD^{-1} \\ -D^{-1}C(A-BD^{-1}C)^{-1} &amp; D^{-1}+D^{-1}C(A-BD^{-1}C)^{-1}BD^{-1} \\ \end{matrix}
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>We actually use a mix of these two forms, 2nd row from the first form, and 1st row from the second form.</p>
</div>
<div class="stemblock">
<div class="content">
\[{\begin{matrix} A &amp; B \\ C &amp; D \\ \end{matrix}}^{-1}=\begin{matrix} (A-BD^{-1}C)^{-1} &amp; -(A-BD^{-1}C)^{-1}BD^{-1} \\ -(D-CA^{-1}B)^{-1}CA^{-1} &amp; (D-CA^{-1}B)^{-1} \\ \end{matrix}\]
</div>
</div>
<div class="paragraph">
<p>This choice might not seem obvious. Take the first form for example, it seems we only need to calculate two 2x2 matrix inverse: \(A^{-1}\) and \((D-CA^{-1} B)^{-1}\), however it can be further simplified by proper derivation. Since each corresponding sub-matrices equals to each other, it doesn’t matter which form you choose to work your math on. We just select the easier row from both forms.</p>
</div>
<div class="paragraph">
<p>Before we start derivation, we need to introduce some concepts. The adjugate of matrix \(A\) is defined as \(A\operatorname{adj}(A)=\left|A\right|I\), where \(\left|A\right|\) is determinant of \(A\). For convenience, in this post we denote adjugate matrix as \(A^{\#}=\operatorname{adj}(A)\). So we can change inverse calculation to adjugate calculation by \(A^{-1}=\frac{1}{\left|A\right|}A^{\#}\). Adjugate of 2x2 matrix is:</p>
</div>
<div class="stemblock">
<div class="content">
\[A^{\#}={\begin{matrix} A_0 &amp; A_1 \\ A_2 &amp; A_3 \\ \end{matrix}}^{\#}=\begin{matrix} A_3 &amp; -A_1 \\ -A_2 &amp; A_0 \\ \end{matrix}\]
</div>
</div>
<div class="paragraph">
<p>Adjugate of 2x2 matrix has the following property: \((AB)^{\#}=B^{\#}\), \(A^{\#}\),\((A^{\#})^{\#}=A\), \((cA)^{\#}=cA^{\#}\).</p>
</div>
<div class="paragraph">
<p>For determinant of 2x2 matrix, we will use the following properties: \(\left|A\right|={A_0}{A_3}-{A_1}{A_2}\), \(\left|-A\right|=\left|A\right|\), \(\left|AB\right|=\left|A\right|\left|B\right|\), \(\left|A+B\right|=\left|A\right|\left|B\right|\operatorname{tr}(A^{\#}{B})\).</p>
</div>
<div class="paragraph">
<p>For trace of matrix we have \(\operatorname{tr}(AB)=\operatorname{tr}(BA)\), \(\operatorname{tr}(-A)=-\operatorname{tr}(A)\).</p>
</div>
<div class="paragraph">
<p>Finally for our block matrices \(M={\begin{matrix} A &amp; B \\ C &amp; D \\ \end{matrix}}\), the determinant is</p>
</div>
<div class="stemblock">
<div class="content">
\[\left|M\right|=\left|A\right|\left|D-CA^{-1}B\right|=\left|D\right|\left|A-BD^{-1}C\right|=\left|AD-BC\right|\]
</div>
</div>
<div class="paragraph">
<p>I only listed properties needed for derivation. If you are not familiar with these concepts, or want to know more about them, take a look at the wiki pages above.</p>
</div>
<div class="paragraph">
<p>Let \(M^{-1}={\begin{matrix} A &amp; B \\ C &amp; D \\ \end{matrix}}^{-1}={\begin{matrix} X &amp; Y \\ Z &amp; W \\ \end{matrix}}\).Let’s start with the top left corner.</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
X&amp;=(A-BD^{-1}C)^{-1}\\
&amp;=\frac{1}{\left|A-BD^{-1}C\right|}(A-\frac{1}{\left|D\right|}BD^{\#}C)^{\#}\\
&amp;=\frac{1}{\left|D\right|\left|A-BD^{-1}C\right|}(\left|D\right|A-BD^{\#}C)^{\#}\\
&amp;=\frac{1}{\left|M\right|}(\left|D\right|A-B(D^{\#}C))^{\#}
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Similarly we can derive the bottom right corner:</p>
</div>
<div class="stemblock">
<div class="content">
\[W=(D-CA^{-1}B)^{-1}=\frac{1}{\left|M\right|}(\left|A\right|D-C(A^{\#}B))^{\#}\]
</div>
</div>
<div class="paragraph">
<p>Notice that we put parentheses around \(D^{\#}C\) and \(A^{\#}B\), and you will see the reason soon.
Now let’s do the top right corner, and make use of the result of top left corner \(X\):</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
Y&amp;=-(A-BD^{-1}C)^{-1}BD^{-1}\\
&amp;=-\frac{1}{\left|M\right|\left|D\right|}(\left|D\right|A-B(D^{\#}C))^{\#}(BD^{\#})\\
&amp;=-\frac{1}{\left|M\right|\left|D\right|}(\left|D\right|A-B(D^{\#}C))^{\#}(DB^{\#})^{\#}\\
&amp;=-\frac{1}{\left|M\right|\left|D\right|}(\left|D\right|DB^{\#}A-DB^{\#}B(D^{\#}C))^{\#}\\
&amp;=-\frac{1}{\left|M\right|\left|D\right|}(\left|D\right|D(A^{\#}B)^{\#}-|\left|D\right||\left|B\right|C))^{\#}\\
&amp;=\frac{1}{\left|M\right|}(\left|B\right|C-D(A^{\#}B)^{\#})^{\#}
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>Similarly we can derive the bottom left corner:</p>
</div>
<div class="stemblock">
<div class="content">
\[Z=-(D-CA^{-1}B)^{-1}CA^{-1}=\frac{1}{\left|M\right|}(\left|C\right|B-A(D^{\#}C)^{\#})^{\#}\]
</div>
</div>
<div class="paragraph">
<p>Here we also changed from \(B^{\#}A\) to \((A^{\#}B)^{\#}\), so we can reuse the result of \(A^{\#}B\). Putting them together:</p>
</div>
<div class="stemblock">
<div class="content">
\[M^{-1}={\begin{matrix} A &amp; B \\ C &amp; D \\ \end{matrix}}^{-1}=\frac{1}{\left|M\right|}{\begin{matrix} \begin{array}{} (\left|D\right|A-B(D^{\#}C))^{\#} &amp; (\left|B\right|C-D(A^{\#}B)^{\#})^{\#} \\ (\left|C\right|B-A(D^{\#}C)^{\#})^{\#} &amp; (\left|A\right|D-C(A^{\#}B))^{\#} \\ \end{array} \right]}\]
</div>
</div>
<div class="paragraph">
<p>Now it is clear what kind of calculation we need. We need 2x2 matrix multiply and multiply by adjugate: \(AB\), \(A^{\#}B\) and \(AB^{\#}\). We already know how to do adjugate, but in this case, adjugate can be combined with multiplication so we don’t waste instructions. Just expand the result and rearrange the order, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c++" data-lang="c++">// for row major matrix
// we use __m128 to represent 2x2 matrix as A = | A0  A1 |
//                                              | A2  A3 |
// 2x2 row major Matrix multiply A*B
__forceinline __m128 Mat2Mul(__m128 vec1, __m128 vec2)
{
	return
		_mm_add_ps(	_mm_mul_ps(						 vec1, VecSwizzle(vec2, 0,3,0,3)),
					_mm_mul_ps(VecSwizzle(vec1, 1,0,3,2), VecSwizzle(vec2, 2,1,2,1)));
}
// 2x2 row major Matrix adjugate multiply (A#)*B
__forceinline __m128 Mat2AdjMul(__m128 vec1, __m128 vec2)
{
	return
		_mm_sub_ps(	_mm_mul_ps(VecSwizzle(vec1, 3,3,0,0), vec2),
					_mm_mul_ps(VecSwizzle(vec1, 1,1,2,2), VecSwizzle(vec2, 2,3,0,1)));

}
// 2x2 row major Matrix multiply adjugate A*(B#)
__forceinline __m128 Mat2MulAdj(__m128 vec1, __m128 vec2)
{
	return
		_mm_sub_ps(	_mm_mul_ps(						 vec1, VecSwizzle(vec2, 3,0,3,0)),
					_mm_mul_ps(VecSwizzle(vec1, 1,0,3,2), VecSwizzle(vec2, 2,1,2,1)));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another trick is after we calculate the 2x2 sub matrix, for example \(\left|D\right|A-B(D^{\#}C)\), The final adjugate to get \(X=(\left|D\right|A-B(D^{\#}C))^{\#}\) can be combined with storing 2x2 sub matrices to the final result 4x4 matrix. You can see this at the end of the function.</p>
</div>
<div class="paragraph">
<p>The only thing left if determinant. 2x2 determinant is easy, the problem really the whole 4x4 matrix determinant. Remember the determinant property we give above:</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align*}
\left|M\right|&amp;=\left|AD-BC\right|\\
&amp;=\left|AD\right|+\left|-BC\right|+\operatorname{tr}((AD)^{\#}(-BC))\\
&amp;=\left|A\right|\left|D\right|+\left|B\right|\left|C\right|-\operatorname{tr}(D^{\#}A^{\#}BC)\\
&amp;=\left|A\right|\left|D\right|+\left|B\right|\left|C\right|-\operatorname{tr}((A^{\#}B)(D^{\#}C))
\end{align*}\]
</div>
</div>
<div class="paragraph">
<p>This is good. We need to calculate all sub matrices determinants and matrix \(A^{\#}B\) and \(D^{\#}C\) anyway. And if you derive the trace of 2x2 matrix multiplication:</p>
</div>
<div class="stemblock">
<div class="content">
\[\operatorname{tr}(AB)={A_0}{B_0}+{A_1}{B_2}+{A_2}{B_1}+{A_3}{B_3}\]
</div>
</div>
<div class="paragraph">
<p>This is just a shuffle and a dot product, should be easy enough to translate into instructions.</p>
</div>
<div class="paragraph">
<p>Now we have all pieces ready, here is our function for general 4x4 matrix inverse:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c++" data-lang="c++">// Inverse function is the same no matter column major or row major
// this version treats it as row major
inline Matrix4 GetInverse(const Matrix4&amp; inM)
{
	// use block matrix method
	// A is a matrix, then i(A) or iA means inverse of A, A# (or A_ in code) means adjugate of A, |A| (or detA in code) is determinant, tr(A) is trace

	// sub matrices
	__m128 A = VecShuffle_0101(inM.mVec[0], inM.mVec[1]);
	__m128 B = VecShuffle_2323(inM.mVec[0], inM.mVec[1]);
	__m128 C = VecShuffle_0101(inM.mVec[2], inM.mVec[3]);
	__m128 D = VecShuffle_2323(inM.mVec[2], inM.mVec[3]);

	__m128 detA = _mm_set1_ps(inM.m[0][0] * inM.m[1][1] - inM.m[0][1] * inM.m[1][0]);
	__m128 detB = _mm_set1_ps(inM.m[0][2] * inM.m[1][3] - inM.m[0][3] * inM.m[1][2]);
	__m128 detC = _mm_set1_ps(inM.m[2][0] * inM.m[3][1] - inM.m[2][1] * inM.m[3][0]);
	__m128 detD = _mm_set1_ps(inM.m[2][2] * inM.m[3][3] - inM.m[2][3] * inM.m[3][2]);

#if 0 // for determinant, float version is faster
	// determinant as (|A| |B| |C| |D|)
	__m128 detSub = _mm_sub_ps(
		_mm_mul_ps(VecShuffle(inM.mVec[0], inM.mVec[2], 0,2,0,2), VecShuffle(inM.mVec[1], inM.mVec[3], 1,3,1,3)),
		_mm_mul_ps(VecShuffle(inM.mVec[0], inM.mVec[2], 1,3,1,3), VecShuffle(inM.mVec[1], inM.mVec[3], 0,2,0,2))
	);
	__m128 detA = VecSwizzle1(detSub, 0);
	__m128 detB = VecSwizzle1(detSub, 1);
	__m128 detC = VecSwizzle1(detSub, 2);
	__m128 detD = VecSwizzle1(detSub, 3);
#endif

	// let iM = 1/|M| * | X  Y |
	//                  | Z  W |

	// D#C
	__m128 D_C = Mat2AdjMul(D, C);
	// A#B
	__m128 A_B = Mat2AdjMul(A, B);
	// X# = |D|A - B(D#C)
	__m128 X_ = _mm_sub_ps(_mm_mul_ps(detD, A), Mat2Mul(B, D_C));
	// W# = |A|D - C(A#B)
	__m128 W_ = _mm_sub_ps(_mm_mul_ps(detA, D), Mat2Mul(C, A_B));

	// |M| = |A|*|D| + ... (continue later)
	__m128 detM = _mm_mul_ps(detA, detD);

	// Y# = |B|C - D(A#B)#
	__m128 Y_ = _mm_sub_ps(_mm_mul_ps(detB, C), Mat2MulAdj(D, A_B));
	// Z# = |C|B - A(D#C)#
	__m128 Z_ = _mm_sub_ps(_mm_mul_ps(detC, B), Mat2MulAdj(A, D_C));

	// |M| = |A|*|D| + |B|*|C| ... (continue later)
	detM = _mm_add_ps(detM, _mm_mul_ps(detB, detC));

	// tr((A#B)(D#C))
	__m128 tr = _mm_mul_ps(A_B, VecSwizzle(D_C, 0,2,1,3));
	tr = _mm_hadd_ps(tr, tr);
	tr = _mm_hadd_ps(tr, tr);
	// |M| = |A|*|D| + |B|*|C| - tr((A#B)(D#C)
	detM = _mm_sub_ps(detM, tr);

	const __m128 adjSignMask = _mm_castsi128_ps(_mm_setr_epi32(0x00000000, 0x80000000, 0x80000000, 0x00000000));
	// (1/|M|, -1/|M|, -1/|M|, 1/|M|)
	__m128 rDetM = _mm_xor_ps(_mm_div_ps(_mm_set1_ps(1.f), detM), adjSignMask);

	X_ = _mm_mul_ps(X_, rDetM);
	Y_ = _mm_mul_ps(Y_, rDetM);
	Z_ = _mm_mul_ps(Z_, rDetM);
	W_ = _mm_mul_ps(W_, rDetM);

	Matrix4 r;

	// apply adjugate and store, here we combine adjugate shuffle and store shuffle
	// btw adjuagate fuction: Adj(Vec) = VecXor(VecSwizzle(Vec, 3,1,2,0), adjSignMask)
	r.mVec[0] = VecShuffle(X_, Y_, 3,1,3,1);
	r.mVec[1] = VecShuffle(X_, Y_, 2,0,2,0);
	r.mVec[2] = VecShuffle(Z_, W_, 3,1,3,1);
	r.mVec[3] = VecShuffle(Z_, W_, 2,0,2,0);

	return r;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As side products of this function, it also gives you optimized version of calculating determinant and adjugate of 4x4 matrix. There are two things I want to talk a little bit more.</p>
</div>
<div class="paragraph">
<p>When we calculate the determinants of sub matrices, I do have a version to calculate 4 determinant in one go. However calculate them separately and use _mm_set1_ps to load into vector unit is proven to be faster on my CPU. My guess is since we need them to be separated anyway, even if I can calculate them together I need to use 4 shuffles to separate them out, which is not worth the effort, but I’m not sure. You should test performance in both version.</p>
</div>
<div class="paragraph">
<p>Also when calculating trace, I’m using two _mm_hadd_ps to sum up 4 components and have the result in all 4 components. There are a lot of ways to do the same thing. From what I tested, they yield similar performance, so I choose the one with less instructions. Again it could be different on different target platforms, and you should test them.</p>
</div>
<div class="paragraph">
<p>So how our functions perform? The following measurement and comparison is done in August 2017. We use __rdtsc to count cycles. For each test we loop 10 million times and measure the average cycle counts. We do 5 groups of tests and here is the result on Intel Haswell:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="https://github.com/lxjk/lxjk.github.io/raw/master/images/matrixinverse/fig1.png" alt="fig1.png" width="600">
</div>
<div class="title">Figure 2</div>
</div>
<div class="paragraph">
<p>The first three columns are our 3 versions of functions. The SIMD version of general 4x4 matrix inverse only cost less than half (44%) of the float version. And if you know the matrix is a transform matrix, it would cost less than a quarter (21%) of the float version. The more information you have as a programmer, the less work the machine need to do.</p>
</div>
<div class="paragraph">
<p>Think about that question again, do we really need to inverse a matrix. If we are using transform matrix and all we do is inverse transform a point or vector temporarily (so no need to save inverse matrix for other calculations), write an inverse transform function, which is faster than get inverse matrix and then transform. Hopefully this will help you choose which function to write or use, and how to make it fast.</p>
</div>
</div>
<div class="sect2">
<h3 id="_appendix">Appendix</h3>
<div class="paragraph">
<p>This is column major area. The first two functions for transform matrix is exactly the same in column major. Here is the general matrix inverse and helper functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c++" data-lang="c++">// for column major matrix
// we use __m128 to represent 2x2 matrix as A = | A0  A2 |
//                                              | A1  A3 |
// 2x2 column major Matrix multiply A*B
__forceinline __m128 Mat2Mul(__m128 vec1, __m128 vec2)
{
	return
		_mm_add_ps(	_mm_mul_ps(						 vec1, VecSwizzle(vec2, 0,0,3,3)),
					_mm_mul_ps(VecSwizzle(vec1, 2,3,0,1), VecSwizzle(vec2, 1,1,2,2)));
}
// 2x2 column major Matrix adjugate multiply (A#)*B
__forceinline __m128 Mat2AdjMul(__m128 vec1, __m128 vec2)
{
	return
		_mm_sub_ps(	_mm_mul_ps(VecSwizzle(vec1, 3,0,3,0), vec2),
					_mm_mul_ps(VecSwizzle(vec1, 2,1,2,1), VecSwizzle(vec2, 1,0,3,2)));

}
// 2x2 column major Matrix multiply adjugate A*(B#)
__forceinline __m128 Mat2MulAdj(__m128 vec1, __m128 vec2)
{
	return
		_mm_sub_ps(	_mm_mul_ps(						 vec1, VecSwizzle(vec2, 3,3,0,0)),
					_mm_mul_ps(VecSwizzle(vec1, 2,3,0,1), VecSwizzle(vec2, 1,1,2,2)));
}

// Inverse function is the same no matter column major or row major
// this version treats it as column major
inline Matrix4 GetInverse(const Matrix4&amp; inM)
{
	// use block matrix method
	// A is a matrix, then i(A) or iA means inverse of A, A# (or A_ in code) means adjugate of A, |A| (or detA in code) is determinant, tr(A) is trace

	// sub matrices
	__m128 A = VecShuffle_0101(inM.mVec[0], inM.mVec[1]);
	__m128 C = VecShuffle_2323(inM.mVec[0], inM.mVec[1]);
	__m128 B = VecShuffle_0101(inM.mVec[2], inM.mVec[3]);
	__m128 D = VecShuffle_2323(inM.mVec[2], inM.mVec[3]);

	__m128 detA = _mm_set1_ps(inM.m[0][0] * inM.m[1][1] - inM.m[0][1] * inM.m[1][0]);
	__m128 detC = _mm_set1_ps(inM.m[0][2] * inM.m[1][3] - inM.m[0][3] * inM.m[1][2]);
	__m128 detB = _mm_set1_ps(inM.m[2][0] * inM.m[3][1] - inM.m[2][1] * inM.m[3][0]);
	__m128 detD = _mm_set1_ps(inM.m[2][2] * inM.m[3][3] - inM.m[2][3] * inM.m[3][2]);

#if 0 // for determinant, float version is faster
	// determinant as (|A| |C| |B| |D|)
	__m128 detSub = _mm_sub_ps(
		_mm_mul_ps(VecShuffle(inM.mVec[0], inM.mVec[2], 0,2,0,2), VecShuffle(inM.mVec[1], inM.mVec[3], 1,3,1,3)),
		_mm_mul_ps(VecShuffle(inM.mVec[0], inM.mVec[2], 1,3,1,3), VecShuffle(inM.mVec[1], inM.mVec[3], 0,2,0,2))
		);
	__m128 detA = VecSwizzle1(detSub, 0);
	__m128 detC = VecSwizzle1(detSub, 1);
	__m128 detB = VecSwizzle1(detSub, 2);
	__m128 detD = VecSwizzle1(detSub, 3);
#endif

	// let iM = 1/|M| * | X  Y |
	//                  | Z  W |

	// D#C
	__m128 D_C = Mat2AdjMul(D, C);
	// A#B
	__m128 A_B = Mat2AdjMul(A, B);
	// X# = |D|A - B(D#C)
	__m128 X_ = _mm_sub_ps(_mm_mul_ps(detD, A), Mat2Mul(B, D_C));
	// W# = |A|D - C(A#B)
	__m128 W_ = _mm_sub_ps(_mm_mul_ps(detA, D), Mat2Mul(C, A_B));

	// |M| = |A|*|D| + ... (continue later)
	__m128 detM = _mm_mul_ps(detA, detD);

	// Y# = |B|C - D(A#B)#
	__m128 Y_ = _mm_sub_ps(_mm_mul_ps(detB, C), Mat2MulAdj(D, A_B));
	// Z# = |C|B - A(D#C)#
	__m128 Z_ = _mm_sub_ps(_mm_mul_ps(detC, B), Mat2MulAdj(A, D_C));

	// |M| = |A|*|D| + |B|*|C| ... (continue later)
	detM = _mm_add_ps(detM, _mm_mul_ps(detB, detC));

	// tr((A#B)(D#C))
	__m128 tr = _mm_mul_ps(A_B, VecSwizzle(D_C, 0,2,1,3));
	tr = _mm_hadd_ps(tr, tr);
	tr = _mm_hadd_ps(tr, tr);
	// |M| = |A|*|D| + |B|*|C| - tr((A#B)(D#C))
	detM = _mm_sub_ps(detM, tr);

	const __m128 adjSignMask = _mm_castsi128_ps(_mm_setr_epi32(0x00000000, 0x80000000, 0x80000000, 0x00000000));
	// (1/|M|, -1/|M|, -1/|M|, 1/|M|)
	__m128 rDetM = _mm_xor_ps(_mm_div_ps(_mm_set1_ps(1.f), detM), adjSignMask);

	X_ = _mm_mul_ps(X_, rDetM);
	Y_ = _mm_mul_ps(Y_, rDetM);
	Z_ = _mm_mul_ps(Z_, rDetM);
	W_ = _mm_mul_ps(W_, rDetM);

	Matrix4 r;

	// apply adjugate and store, here we combine adjugate shuffle and store shuffle
	// btw adjuagate fuction: Adj(Vec) = VecXor(VecSwizzle(Vec, 3,1,2,0), adjSignMask)
	r.mVec[0] = VecShuffle(X_, Z_, 3,1,3,1);
	r.mVec[1] = VecShuffle(X_, Z_, 2,0,2,0);
	r.mVec[2] = VecShuffle(Y_, W_, 3,1,3,1);
	r.mVec[3] = VecShuffle(Y_, W_, 2,0,2,0);

	return r;
}</code></pre>
</div>
</div>
</div>
    </section>
	
	<footer class="post-footer">


            <figure class="author-image">
                <a class="img" href="https://lxjk.github.io/author/lxjk/" style="background-image: url(https://avatars0.githubusercontent.com/u/3803294?v&#x3D;4)"><span class="hidden">Eric Zhang's Picture</span></a>
            </figure>

            <section class="author">
                <h5>WRITTEN BY</h5>
                <h4>Eric Zhang</h4>

				
            </section>


            <section class="share">
                <h5>SHARE THIS POST</h5>
                <a href="https://twitter.com/intent/tweet?text=Fast%204x4%20Matrix%20Inverse%20with%20SSE%20SIMD%2C%20Explained&amp;url=https://lxjk.github.io/2017/09/03/Fast-4x4-Matrix-Inverse-with-SSE-SIMD-Explained.html"
                    onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
					<i class='icon icon-social-twitter'></i>
					<span class="hidden">Twitter</span>
                </a>
                <a href="https://www.facebook.com/sharer/sharer.php?u=https://lxjk.github.io/2017/09/03/Fast-4x4-Matrix-Inverse-with-SSE-SIMD-Explained.html"
                    onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
					<i class='icon icon-social-facebook'></i>
                    <span class="hidden">Facebook</span>
                </a>
                <a href="https://plus.google.com/share?url=https://lxjk.github.io/2017/09/03/Fast-4x4-Matrix-Inverse-with-SSE-SIMD-Explained.html"
                   onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
					<i class='icon icon-social-google-plus'></i>
					<span class="hidden">Google-plus</span>
                </a>
            </section>

        </footer>

  </article>

  
  <section class="post-comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'lxjkgithub'; // required: replace example with your forum shortname
        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  </section>
  



            <footer class="footer">
                <span class="footer__copyright">&copy; 2017. All rights reserved.</span>
                <span class="footer__copyright"><a href="http://uno.daleanthony.com" title="link to page for Uno Ghost theme">Uno theme</a> by <a href="http://daleanthony.com" title="link to website for Dale-Anthony">Dale-Anthony</a></span>
                <span class="footer__copyright">Proudly published with <a href="http://hubpress.io" title="link to Hubpress website">Hubpress</a></span>
            </footer>
        </div>
    </div>

    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js?v="></script> <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.9.0/moment-with-locales.min.js?v="></script> <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js?v="></script> 
      <script type="text/javascript">
        jQuery( document ).ready(function() {
          // change date with ago
          jQuery('ago.ago').each(function(){
            var element = jQuery(this).parent();
            element.html( moment(element.text()).fromNow());
          });
        });

        hljs.initHighlightingOnLoad();
      </script>

    <script type="text/javascript" src="//lxjk.github.io/themes/uno/assets/js/main.js?v=1504482311354"></script>
    
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-86497933-1', 'auto');
    ga('send', 'pageview');

    </script>

</body>
</html>
